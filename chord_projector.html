<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Projector</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            overflow: hidden; /* Prevents scrolling on the body */
        }

        body {
            display: flex;
            flex-direction: column;
            padding: 10px;
            font-size: 16px; /* Default size that will be configurable */
            box-sizing: border-box;
        }

        .controls-wrapper {
            margin-bottom: 10px;
            display: flex;
            gap: 20px;
        }

        .text-input-container {
            flex: 2; /* Takes 2/3 of the space */
        }

        .controls-container {
            flex: 1; /* Takes 1/3 of the space */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .controls {
            margin-bottom: 10px;
        }

        .controls label {
            display: inline-block;
            margin-right: 10px;
        }

        .controls input {
            width: 50px;
            margin-right: 15px;
        }

        .keyboard-shortcuts {
            margin-top: auto;
            font-size: 12px;
            color: #666;
        }

        textarea {
            width: 100%;
            height: 120px; /* Taller text area */
            resize: none;
            box-sizing: border-box;
        }

        .container {
            flex: 1;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden; /* Prevents scrolling */
            margin-top: 10px;
            border: 1px solid #ddd;
            position: relative;
        }

        .container.fullscreen {
            margin-top: 0;
            border: none;
        }

        .multi-column {
            width: 100%;
            height: 100%;
            display: flex;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden; /* No vertical scrolling */
        }

        .content-columns {
            display: flex;
        }

        .column {
            height: 100%;
            margin-right: 20px; /* Default gap, will be controlled by JS */
            position: relative;
            padding-right: 10px;
            flex-shrink: 0; /* Prevent columns from shrinking */
        }

        .has-horizontal-overflow-right::after {
            content: '';
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0px;
            width: 20px;
            background: linear-gradient(.25turn, transparent, rgba(255,0,0,0.1) 40%, rgba(255,0,0,0.5) 80%);
            pointer-events: none;
            z-index: 1;
        }

        .has-horizontal-overflow-left::before {
            content: '';
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0px;
            width: 20px;
            background: linear-gradient(to left, transparent, rgba(255,0,0,0.1) 40%, rgba(255,0,0,0.5) 80%);
            pointer-events: none;
            z-index: 1;
        }

        /* column separator */
        .column:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 1px;
            background-color: #ccc;
            z-index: 0;
        }

        .column:last-child {
            margin-right: 0;
            padding-right: 0;
        }

        p.line {
            font-family: 'Roboto Mono', 'Courier New', monospace;
            line-height: 1.3; /* Tighter line spacing */
            margin: 0;
            padding: 0;
            white-space: pre; /* Preserves whitespace including multiple spaces */
            text-overflow: clip; /* Clips text that doesn't fit */
        }

        p.line.empty-line {
            line-height: 1;
        }

        p.line .chord {
            font-weight: 700;
            background: rgba(0,0,0,0.09);
            border-radius: 3px;
            margin-left: -.13em;
            padding-left: .13em;
            margin-right: -.13em;
            padding-right: .13em;
        }

        .colorful p.line .chord {
            color: rgb(0, 123, 255);
            background: rgb(240, 248, 255);
        }

        p.line .header-line {
            color: rgb(255, 255, 255);
            background: rgb(142, 68, 173, 0.8);
            border-radius: 6px;
            padding-left: 6px;
            padding-right: 5px;

            margin-top: 17px;
            margin-bottom: 12px;
            display: inline-block;
            font-size: 0.98em;
            letter-spacing: 1px;
        }

        #left-edge-pixel-anchor {
            width: 1px;
            height: 1px;
            top: 0;
            left: 0;
        }

        #right-edge-pixel-anchor {
            width: 1px;
            height: 1px;
            top: 0;
            right: 0;
        }
    </style>
</head>
<body>
    <div class="controls-wrapper" id="controls-wrapper">
        <div class="text-input-container">
            <textarea id="input-text" placeholder="Enter your text here..."></textarea>
        </div>

        <div class="controls-container">
            <div class="controls">
                <label for="font-size">Font size (px):</label>
                <input type="number" id="font-size" min="8" max="36" value="16">
            </div>

            <div class="keyboard-shortcuts">
                Keyboard shortcuts:
                <strong>h</strong> - hide/show controls,
                <strong>n</strong> - decrease font size,
                <strong>m</strong> - increase font size
            </div>
        </div>
    </div>

    <div class="container">
        <div class="multi-column">
            <div id="left-edge-pixel-anchor"></div>
            <div class="content-columns" id="content"></div>
            <div id="right-edge-pixel-anchor"></div>
        </div>
    </div>

    <script>
        const fontSizeInput = document.getElementById('font-size');
        const inputText = document.getElementById('input-text');
        const contentDiv = document.getElementById('content');
        const controlsWrapper = document.getElementById('controls-wrapper');
        const container = document.querySelector('.container');

        const rgx = {
            chord: /(?<chord>(^|(?<=[\s|()-]))(?<root>C|C#|Db|D|D#|Eb|E|F|F#|Gb|G|G#|Ab|A|A#|Bb|B|Hb|H)(?<variant>m|maj|min|dim|aug|sus|sus2|sus4|7sus|7sus2|7sus4|add9|add11|madd9|madd11|M|m6|m7|min6|min7|min11|maj7|maj9|mmaj7|mmaj9|7|9|11|13|6|2|4|5|°|ø|♭5|#5|b5|#9|b9)?(?:\/(?<bass>C|C#|Db|D|D#|Eb|E|F|F#|Gb|G|G#|Ab|A|A#|Bb|B|Hb|H))?($|(?=[\s|()-*])))/,
            header: /\s*\[([^\]]+)\]\s*/,
            fingering: /((\d|x){4,7})/,
            brackets: /(\[|\])/,
        };

        // Track if controls are visible
        let controlsVisible = true;

        // Load initial text on page load
        loadTextFromURL();

        // Initialize with content
        updateContent();

        // Add event listeners to all inputs to update automatically
        fontSizeInput.addEventListener('input', updateContent);
        inputText.addEventListener('input', () => {
            updateUrlToMatchInputText();
            updateContent();
        });

        // Also update on window resize
        window.addEventListener('resize', updateContent);

        window.addEventListener('hashchange', () => {
            loadTextFromURL();
            updateContent();
        });

        if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window &&
            "intersectionRatio" in window.IntersectionObserverEntry.prototype) {

            const leftObserver = new IntersectionObserver(entries => {
                if (entries[0].isIntersecting) {
                    contentDiv.classList.remove('has-horizontal-overflow-left');
                } else {
                    contentDiv.classList.add('has-horizontal-overflow-left');
                }
            });

            const rightObserver = new IntersectionObserver(entries => {
                console.log("observer triggered on right, visible=" + entries[0].isIntersecting);
                if (entries[0].isIntersecting) {
                    contentDiv.classList.remove('has-horizontal-overflow-right');
                } else {
                    contentDiv.classList.add('has-horizontal-overflow-right');
                }
            });

            leftObserver.observe(document.querySelector("#left-edge-pixel-anchor"));
            rightObserver.observe(document.querySelector("#right-edge-pixel-anchor"));
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Check if any input has focus
            const anyInputHasFocus =
                document.activeElement === inputText ||
                document.activeElement === fontSizeInput;

            if (anyInputHasFocus) {
                return;
            }

            if (e.key.toLowerCase() === 'h') { // Toggle controls visibility with 'h'
                controlsVisible = !controlsVisible;
                controlsWrapper.style.display = controlsVisible ? 'flex' : 'none';

                if (controlsVisible) {
                    container.classList.remove('fullscreen');
                } else {
                    container.classList.add('fullscreen');
                }

                updateContent();
            } else if (e.key.toLowerCase() === 'n') { // Decrease font size with 'n'
                const currentSize = parseFloat(fontSizeInput.value);
                if (currentSize > 8) { // Minimum font size
                    fontSizeInput.value = currentSize - 0.5;
                    updateContent();
                }
            } else if (e.key.toLowerCase() === 'm') { // Increase font size with 'm'
                const currentSize = parseFloat(fontSizeInput.value);
                if (currentSize < 36) { // Maximum font size
                    fontSizeInput.value = currentSize + 0.5;
                    updateContent();
                }
            }
        });

        function getHashParam(param) {
            if (!window.location.hash) {
                return null;
            }

            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            return hashParams.get(param);
        }

        function setHashParam(param, value) {
            const hashParams = new URLSearchParams(window.location.hash && window.location.hash.substring(1) || '');
            hashParams.set(param, value);
            window.location.hash = '#' + hashParams.toString();
        }

        function isEmptyLine(line) {
            return line == undefined || line.trim() === '';
        }

        function isHeaderLine(line) {
            if (isEmptyLine(line)) {
                return false;
            }

            const headerRegexGlobal = new RegExp(rgx.header.source, "g");
            return line.match(headerRegexGlobal);
        }

        function isChordLine(line) {
            if (isEmptyLine(line)) {
                return false;
            }

            const allowedWithChords = `([\\s|%-*()]|${rgx.fingering.source}|${rgx.brackets.source})`;
            const onlyChordsRegex = new RegExp(`^(${allowedWithChords}*${rgx.chord.source}${allowedWithChords}*)+$`);
            return line.match(onlyChordsRegex);
        }

        function isTextLine(line) {
            return !isChordLine(line) && !isHeaderLine(line) && !isEmptyLine(line);
        }

        function encodeHtml(str) {
            const el = document.createElement('div');
            el.textContent = str;
            return el.innerHTML;
        }

        function spanifyChords(line) {
            const chordRegexGlobal = new RegExp(rgx.chord.source, "g");
            const headerRegexGlobal = new RegExp(rgx.header.source, "g");

            line = encodeHtml(line);

            const headerMatch = line.match(headerRegexGlobal);
            if (headerMatch) {
                return line.replace(headerRegexGlobal, '<span class="header-line">$1</span>');
            }

            const chordMatch = line.match(chordRegexGlobal);
            if (!chordMatch) {
                return line;
            }
            if (chordMatch.length < 2 && !isChordLine(line)) {
                return line;
            }

            return line.replaceAll(chordRegexGlobal, '<span class="chord">$&</span>');
        }

        function createLineHtmlElement(line) {
            const p = document.createElement('p');
            p.className = 'line';

            if (isEmptyLine(line)) {
                p.className += ' empty-line';
                p.innerHTML = '&nbsp;';
            } else {
                p.innerHTML = spanifyChords(line);
            }

            return p;
        }

        function loadTextFromURL() {
            const title = getHashParam('title');
            const text = getHashParam('text');

            if (text && inputText.value !== text) {
                inputText.value = text;

                // Hide controls by default when text is passed via URL
                controlsVisible = false;
                controlsWrapper.style.display = 'none';
                container.classList.add('fullscreen');
            }

            if (title) {
                document.title = title;
            }
        }

        function updateUrlToMatchInputText() {
            const existingTextHash = getHashParam('text');

            if (!existingTextHash || inputText.value != existingTextHash) {
                setHashParam('text', inputText.value);
            }
        }

        function parseLines() {
            const rawLines = inputText.value.split('\n');
            const result = [];

            for (let i = 0; i < rawLines.length; i++) {
                const line = rawLines[i];
                const previousLine = i > 0 && rawLines[i - 1];
                const nextLine = i < rawLines.length - 1 && rawLines[i + 1];

                if (isEmptyLine(line) && (isHeaderLine(nextLine) || isHeaderLine(previousLine))) {
                    continue;
                }

                result.push(line.trimEnd()); // Trim whitespace from the end of each line
            };

            // Remove empty lines at the end of the text
            while (result.length > 0 && isEmptyLine(result[result.length - 1])) {
                result.pop();
            }

            return result;
        }

        function updateContent() {
            const lines = parseLines();

            // Clear content
            contentDiv.innerHTML = '';

            // Set font size
            document.body.style.fontSize = parseFloat(fontSizeInput.value) + 'px';

            // Create a temporary element to measure text widths and heights
            const measureEl = document.createElement('span');
            measureEl.style.position = 'absolute';
            measureEl.style.visibility = 'hidden';
            document.body.appendChild(measureEl);

            // Calculate line metrics (width and height)
            const lineMetrics = lines.map(line => {
                const lineHtmlElement = createLineHtmlElement(line);

                measureEl.appendChild(lineHtmlElement);
                const width = lineHtmlElement.getBoundingClientRect().width;
                const height = lineHtmlElement.getBoundingClientRect().height;
                measureEl.removeChild(lineHtmlElement);

                return { width, height, line };
            });

            // Available space
            const availableWidth = contentDiv.clientWidth;
            const availableHeight = contentDiv.clientHeight;

            // Create columns dynamically
            const columns = [];
            let currentColumn = null;
            let currentHeight = 0;

            for (let i = 0; i < lineMetrics.length; i++) {
                const metric = lineMetrics[i];
                const nextMetric = (i < lineMetrics.length - 1) ? lineMetrics[i + 1] : null;

                // If we don't have a column yet or adding this line would exceed column height,
                // create a new column (if there's space)
                if (!currentColumn ||
                    currentHeight + metric.height > availableHeight ||
                    (nextMetric && isChordLine(metric.line) && isTextLine(nextMetric.line) &&
                     currentHeight + metric.height + nextMetric.height > availableHeight)) {

                    if (isEmptyLine(metric.line.trim())) {
                        continue;
                    }

                    currentColumn = {
                        div: document.createElement('div'),
                        width: 0,
                        lines: []
                    };
                    currentColumn.div.className = 'column';
                    columns.push(currentColumn);
                    currentHeight = 0;
                }

                // Add the line to the current column
                currentColumn.lines.push(metric);
                currentColumn.width = Math.max(currentColumn.width, metric.width);
                currentHeight += metric.height;
            }

            // Render columns with their content
            columns.forEach((column, i) => {
                column.div.style.width = column.width + 'px';
                column.div.style.marginRight = (i < columns.length - 1) ? '20px' : '0';

                column.lines.forEach(metric => {
                    const lineHtmlElement = createLineHtmlElement(metric.line);
                    column.div.appendChild(lineHtmlElement);
                });

                contentDiv.appendChild(column.div);
            });

            // Clean up measurement element
            document.body.removeChild(measureEl);
        }
    </script>
</body>
</html>