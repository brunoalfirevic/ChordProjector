<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Projector</title>
    <link rel="icon" type="image/svg+xml" href="favicon-browse.svg" id="favicon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Music&family=Roboto+Mono:wght@100..700&display=block" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Julia Mono Webfont';
            font-style: normal;
            font-weight: 400;
            font-display: block;
            src: url(fonts/JuliaMono-Regular.woff2) format('woff2');
        }

        @font-face {
            font-family: 'Julia Mono Webfont';
            font-style: normal;
            font-weight: 300;
            font-display: block;
            src: url(fonts/JuliaMono-Light.woff2) format('woff2');
        }

        @font-face {
            font-family: 'Julia Mono Webfont';
            font-style: normal;
            font-weight: 700;
            font-display: block;
            src: url(fonts/JuliaMono-SemiBold.woff2) format('woff2');
        }

        @font-face {
            font-family: 'Adobe NotDef';
            font-display: block;
            src: url('fonts/AdobeNotDef-Regular.woff2') format('woff2');
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Roboto Mono', 'Julia Mono Webfont', 'Courier New', monospace;
            overflow: hidden; /* Prevents scrolling on the body */
        }

        body {
            display: flex;
            flex-direction: column;
            padding: 5px;
            font-size: 15px; /* Default size that will be configurable */
            box-sizing: border-box;
        }

        .controls-wrapper {
            display: flex;
            gap: 10px;
            padding-bottom: 10px;
            box-sizing: border-box;
            border-bottom: 1px solid #ddd;
        }

        .controls-container {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .fullscreen .controls-wrapper {
            display: none;
        }

        .text-input-container {
            flex: 7;
        }

        .controls-container {
            flex: 4;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .controls {
            margin-bottom: 5px;
            font-size: 12px;
        }

        .controls label {
            display: inline-block;
            margin-top: 7px;
            margin-right: 2px;
        }

        .controls input[type="checkbox"] {
            width: 13px;
            margin-top: 8px;
            cursor: pointer;
        }

        .controls input, .controls select {
            margin: 3px;
            width: 50px;
            box-sizing: content-box;
        }

        .controls select {
            padding-block: 1px;
            padding-inline: 3px;
            cursor: pointer;
        }

        .controls button {
            margin: 3px;
            cursor: pointer;
            min-width: 100px;
        }

        .keyboard-shortcuts {
            margin-top: auto;
            font-size: 12px;
            color: #666;
        }

        .detected-key {
            margin-top: auto;
            margin-bottom: 5px;
            font-size: 13px;
            font-style: italic;
        }

        textarea {
            width: 100%;
            height: 100%;
            resize: none;
            box-sizing: border-box;
            font-family: inherit;
            font-size: inherit;
        }

        .overflow-y-hidden {
            overflow-y: hidden;
        }

        .content-wrapper {
            display: flex;
            flex: 1;
            position: relative;
        }

        .content-container {
            display: flex;
            width: 100%;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden; /* No vertical scrolling */
        }

        #content {
            display: flex;
            flex-shrink: 0;
        }

        .column {
            flex-shrink: 0;
            position: relative;
            margin-right: 10px;
            padding-right: 10px;
        }

        .has-horizontal-overflow-left::before,
        .has-horizontal-overflow-right::after {
            content: '';
            position: absolute;
            top: -1px;
            bottom: -5px;
            width: 1010px;
            pointer-events: none;
            z-index: 1;
        }

        .has-horizontal-overflow-left::before {
            left: -1000px;
            background: linear-gradient(to left, transparent, rgba(255,0,0,0.1) 0px, rgba(255,0,0,0.65) 15px, rgba(255,0,0,0.65) 100%);
        }

        .has-horizontal-overflow-right::after {
            right: -1000px;
            background: linear-gradient(.25turn, transparent, rgba(255,0,0,0.1) 0px, rgba(255,0,0,0.65) 15px, rgba(255,0,0,0.65) 100%);
        }

        .fullscreen .has-horizontal-overflow-left::before,
        .fullscreen .has-horizontal-overflow-right::after {
            top: -5px !important;
        }

        /* column separator */
        .column:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 1px;
            background-color: #ccc;
            z-index: 0;
        }

        .column:last-child {
            margin-right: 0;
            padding-right: 0;
        }

        .line {
            line-height: 1.3; /* Tighter line spacing */
            margin: 0;
            padding: 0;
            white-space: pre; /* Preserves whitespace including multiple spaces */
            text-overflow: clip; /* Clips text that doesn't fit */
        }

        .line .chord {
            position: relative;
            z-index: -1; /* to make character around chords appear above the highlighted background */
        }

        .line .chord,
        .line.nashville-legend .note {
            font-weight: 700;
            background-color: rgb(232, 232, 232);
            border-radius: 3px;
            margin-left: -.13em;
            padding-left: .13em;
            margin-right: -.13em;
            padding-right: .13em;
        }

        .colorful-chords .line .chord.nashville .variant-separator,
        .colorful-chords .line .chord.nashville .variant .char[content="‚ö°"] {
            color: rgb(215, 0, 0);
        }

        .colorful-chords .line .chord,
        .colorful-chords .line.nashville-legend .note {
            color: rgb(0, 123, 255);
            background-color: rgb(240, 248, 255);
        }

        .line.nashville-legend {
            padding-bottom: 0.6em;
        }

        .line.nashville-legend .note {
            background-color: initial !important;
        }

        .line.nashville-legend table,
        .line.nashville-legend th,
        .line.nashville-legend td
        {
            border: 1px solid gray;
            border-collapse: collapse;
        }

        .line.nashville-legend th:not(.key-name),
        .line.nashville-legend td:not(.key-name) {
            padding-left: 0.3em;
            padding-right: 0.2em;
            text-align: left;
            width: 2ch;
        }

        .line.nashville-legend .key-name {
            padding-left: 0.3em;
            padding-right: 0.2em;
            font-size: 0.9em;
            text-align: right;
            width: auto;
        }

        .line.nashville-legend .major-degree {
            background-color: rgb(243, 243, 243);
        }

        .line.empty-line {
            line-height: 1;
        }

        .line.empty-line + .line.header-line {
            margin-top: -0.3em;
        }

        .line.header-line + .line.empty-line.followed-by-header-line {
            margin-top: -0.5em;
        }

        .line.header-line {
            padding-bottom: 0.4em;
        }

        .line.header-line .title-container,
        .line.header-line .metadata-container {
            background-color: rgb(232, 232, 232);
            border-radius: 5px;
        }

        .line:not(.header-line) .metadata-container {
            background-color: rgb(232, 232, 232);
            border-radius: 5px;
        }

        .colorful-headers .line:not(.header-line) .metadata-container {
            margin-left: 0.2em;
            margin-right: 0.2em;
            background-color: rgb(210, 250, 210);
        }

        .colorful-headers .line:not(.header-line) .metadata-container .brace {
            color: rgb(210, 250, 210);
        }

        .colorful-headers .line:not(.header-line) .metadata-container .brace:first-child {
            margin-right: -0.2em;
        }

        .colorful-headers .line:not(.header-line) .metadata-container .brace:last-child {
            margin-left: -0.2em;
        }

        .colorful-headers .line.header-line .title {
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 0.98em;
            letter-spacing: 1px;
        }

        .colorful-headers .line.header-line .metadata {
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 0.98em;
            font-style: italic;
        }

        .colorful-headers .line.header-line .title-container {
            background-color: rgb(238, 229, 242);
        }

        .colorful-headers .line.header-line .title-container .bracket {
            font-size: 0.6em;
            color: rgb(232, 232, 232);
        }

        .colorful-headers .line.header-line .metadata-container {
            background-color: rgb(210, 250, 210);
        }

        .colorful-headers .line.header-line .metadata-container .brace {
            font-size: 0.6em;
            color: rgb(210, 250, 210);
        }

        #leftEdgePixelAnchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }

        #rightEdgePixelAnchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }

        .cast-mode-overlay {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            box-sizing: border-box;
            position: fixed;
            left: 0px;
            right: 0px;
            bottom: 0px;
            width: 100%;

            display: flex;
            justify-content: center;
            align-items: flex-start;

            height: 45%;
            padding-top: 80px;

            background: linear-gradient(to bottom,
                rgba(180, 60, 60, 0.0) 0px,
                rgba(180, 60, 60, 0.5) 64px,
                rgba(180, 60, 60, 0.8) 40%,
                rgba(140, 40, 40, 0.95) 100%);
        }

        .cast-mode-overlay .card {
            display: flex;
            align-items: center;
            flex-direction: column;
            border-radius: 12px;
            padding: 24px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 4px 20px rgba(0,0,0,0.7);
        }

        .cast-mode-overlay .title {
            color: white;
            font-weight: 700;
            font-size: 20px;
            text-transform: capitalize;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
            padding: 0px;
            margin: 0px;
            margin-bottom: 16px;
        }

        .cast-mode-overlay .description {
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
            color: rgba(255,255,255,0.95);
            font-size: 14px;
            margin-bottom: 16px;
            max-width: 400px;
        }

        .cast-mode-overlay .title:empty,
        .cast-mode-overlay .artist:empty {
            display: none;
        }

        .cast-mode-overlay button {
            background-color: lightgray;
            color: gray;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }

        .cast-mode-overlay button:enabled {
            cursor: pointer;
            color: #333;
            background-color: white;
        }

        .cast-mode-overlay button:enabled:hover {
            background-color: rgb(239, 239, 239);
        }

        .new-song-info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 1000;
            box-sizing: border-box;
        }

        .new-song-info-overlay .modal {
            position: relative;
            background: linear-gradient(135deg, rgb(30, 58, 95) 0%, rgb(15, 39, 68) 50%, rgb(26, 26, 46) 100%);
            color: white;
            padding: 32px 40px;
            border-radius: 16px;
            text-align: center;
            pointer-events: auto;
            border: 1px solid rgba(147, 197, 253, 0.5);
            overflow: hidden;

            /* Animation properties */
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 0 rgba(59, 130, 246, 0);
        }

        .new-song-info-overlay.visible .modal {
            opacity: 1;
            transform: scale(1);
            box-shadow:
                0 0 60px rgba(59, 130, 246, 0.6),
                0 0 100px rgba(96, 165, 250, 0.4),
                0 0 140px rgba(147, 197, 253, 0.25),
                0 20px 50px rgba(0, 0, 0, 0.3);
        }

        /* Exit animation */
        .new-song-info-overlay.hiding .modal {
            opacity: 0;
            transform: scale(1.05);
            transition: all 1.8s ease-in;
            box-shadow: 0 0 0 rgba(59, 130, 246, 0);
        }

        .new-song-info-overlay .modal .info {
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: rgb(191, 219, 254);
            position: relative;
        }

        .new-song-info-overlay .modal .title {
            font-size: 40px;
            font-weight: 700;
            text-transform: capitalize;
            margin-top: 16px;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .new-song-info-overlay .modal .artist {
            font-size: 32px;
            font-weight: 700;
            text-transform: capitalize;
            margin-top: 12px;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .new-song-info-overlay .modal .title:empty,
        .new-song-info-overlay .modal .artist:empty {
            display: none;
        }

        /* utilities */

        .hidden {
            display: none !important;
        }

        .flex-row {
            display: flex;
            flex-direction: row;
        }

        .flex-column {
            display: flex;
            flex-direction: column;
        }

        .align-flex-end {
            align-items: flex-end;
        }

        .flex1 { flex: 1; }
        .flex2 { flex: 2; }
        .flex3 { flex: 3; }
        .flex4 { flex: 4; }
        .flex5 { flex: 5; }
        .flex6 { flex: 6; }
        .flex7 { flex: 7; }
        .flex8 { flex: 8; }
        .flex9 { flex: 9; }
        .flex10 { flex: 10; }
        .flex11 { flex: 11; }
        .flex12 { flex: 12; }
        .flex13 { flex: 13; }

        /* Even tighter line spacing for tablature*/
        .tablature-line:not(.tablature-timing-line) { line-height: 1 !important;}
        .line.followed-by-tablature-line:not(.tablature-line):not(.empty-line):not(.followed-by-tablature-timing-line) { line-height: 1.15 !important; } */
        .line.followed-by-tablature-line:not(.tablature-line):not(.empty-line) + .tablature-timing-line { line-height: 1.15 !important; }

        .tablature-line .char {
            display: inline-block;
            width: 1ch;
        }

        .polished {
            /* Pretty tablatures */

            .pretty-tablatures {
                .tablature-line .char[content="-"],
                .tablature-line .char[content="|"] {
                    position: relative; display: inline-block; width: 1ch; color: transparent; /* content replacement groundwork */

                    &::after {
                        position: absolute; left: 0; top: 0; color: initial; /* content replacement groundwork */

                        font-weight: 300;
                        color: gray;
                    }

                    &[content="-"]::after { content: '‚îÄ'; }
                }

                .tablature-line.followed-by-tablature-line {
                    .char[content="|"]::after { content: '‚î¨'; }
                    .char[content="|"]:nth-child(2)::after { content: '‚îå'; }
                    .char[content="|"]:last-child::after { content: '‚îê'; }
                }

                .tablature-line:not(.followed-by-tablature-line) {
                    .char[content="|"]::after { content: '‚î¥'; }
                    .char[content="|"]:nth-child(2)::after { content: '‚îî'; }
                    .char[content="|"]:last-child::after { content: '‚îò'; }
                }

                .tablature-line + .tablature-line.followed-by-tablature-line,
                .line.followed-by-tablature-line:not(.tablature-line).has-any-chords + .tablature-line.followed-by-tablature-line {
                    .char[content="|"]::after { content: '‚îº'; }
                    .char[content="|"]:nth-child(2)::after { content: '‚îú'; }
                    .char[content="|"]:last-child::after { content: '‚î§'; }
                }

                .tablature-timing-line .char[content="|"]::after {
                    content: '‚îÇ' !important;
                }

                .tablature-timing-line:not(.followed-by-tablature-line) .char[content="|"]::after {
                    margin-top: -0.3em;
                }

                .line.followed-by-tablature-line:not(.tablature-line).has-any-chords + .tablature-timing-line .char[content="|"]::after {
                    margin-top: -0.2em;
                }

                .line.followed-by-tablature-line:not(.tablature-line) .char[content="|"] {
                    color: transparent;
                }
            }

            /* Specific character styling */

            .line:not(.tablature-line):not(.followed-by-tablature-line) .char[content="|"] {
                display: inline-block;
                transform: translateY(-1px) scaleY(1.2);
                font-weight: 700;
            }

            .line .chord-suffix .char[content="."],
            .tablature-timing-line .char[content="."] {
                font-weight: 700;
            }

            /* Stylized accidentals */
            .stylize-accidentals .line .chord .char[content="b"],
            .stylize-accidentals .line .chord .char[content="#"],
            .stylize-accidentals .line.nashville-legend .key-name .char[content="b"],
            .stylize-accidentals .line.nashville-legend .key-name .char[content="#"],
            .stylize-accidentals .line.nashville-legend .note .char[content="b"],
            .stylize-accidentals .line.nashville-legend .note .char[content="#"],
            .stylize-accidentals .line .metadata-key-name .char[content="b"],
            .stylize-accidentals .line .metadata-key-name .char[content="#"],
            .nashville-legend .nashville-numeral .char[content="b"],
            .line .chord.nashville .chord-name .char[content="b"],
            .line .chord.nashville .bass .char[content="b"] {
                position: relative; display: inline-block; width: 1ch; color: transparent; /* content replacement groundwork */

                &::after {
                    position: absolute; left: 0; top: 0; color: initial; /* content replacement groundwork */

                    width: 1ch;
                    text-align: center;
                    font-weight: 700;
                }

                &[content="b"]::after {
                    content: '‚ô≠';
                    text-align: left;
                    font-family: 'Arial Unicode MS', 'Julia Mono Webfont', monospace;
                }
                &[content="#"]::after {
                    content: '‚ôØ';
                    font-family: 'Arial Unicode MS', 'Julia Mono Webfont', monospace;
                }
            }

            /* Restore the text color that was set to 'initial' in the stylized accidentals replacement CSS block */
            .colorful-chords .line .chord .char::after,
            .colorful-chords .line.nashville-legend .note .char::after {
                color: rgb(0, 123, 255) !important;
            }

            /* Symbol for pushed chord */
            .chord-prefix .char[content="‚§∫"],
            .chord-prefix .char[content="·ëâ"],
            .chord-prefix .char[content="<"],
            .chord-prefix .char[content=">"],
            .chord-prefix .char[content="~"] {
                position: relative; display: inline-block; width: 1ch; color: transparent; /* content replacement groundwork */

                &::after {
                    position: absolute; left: 0; top: 0; color: initial; /* content replacement groundwork */

                    content: '‚§∫';

                    margin-top: -0.2em;
                    font-weight: 700;
                }
            }

            /* Musical notes */
            .line .chord-suffix,
            .tablature-timing-line {
                .char[content="ùÑê"],
                .char[content="‚óá"],
                .char[content="‚ë†"],
                .char[content="‚ë°"],
                .char[content="‚ë£"],
                .char[content="‚ëß"],
                .char[content="‚ëØ"],
                .char[content="‚ù∂"],
                .char[content="‚ù∑"],
                .char[content="‚ùπ"],
                .char[content="‚ùΩ"],
                .char[content="‚ì∞"],
                .char[content="‚ô™"],
                .char[content="‚ô©"],
                .char[content="‚åá"] {
                    position: relative; display: inline-block; width: 1ch; color: transparent; /* content replacement groundwork */

                    &::after {
                        position: absolute; left: 0; top: 0; color: initial; /* content replacement groundwork */

                        width: 1ch;
                        text-align: center;
                        font-family: 'Noto Music';
                        font-weight: 700;
                    }

                    &[content="ùÑê"]::after { content: 'ùÑê'; margin-top: 0.3em;}

                    &[content="‚ë†"]::after, &[content="‚óá"]::after { content: 'ùÖù'; }
                    &[content="‚ë°"]::after { content: 'ùÖû'; }
                    &[content="‚ëß"]::after, &[content="‚ô™"]::after { content: 'ùÖ†'; }
                    &[content="‚ë£"]::after, &[content="‚ô©"]::after { content: 'ùÖü'; }
                    &[content="‚ëØ"]::after { content: 'ùÖ°'; }

                    &[content="‚ù∂"]::after { content: 'ùÑª'; }
                    &[content="‚ù∑"]::after { content: 'ùÑº'; }
                    &[content="‚ùπ"]::after, &[content="‚åá"]::after { content: 'ùÑΩ'; }
                    &[content="‚ùΩ"]::after { content: 'ùÑæ'; }
                    &[content="‚ì∞"]::after { content: 'ùÑø'; }
                }
            }
        }
    </style>
</head>
<body>
    <div id="controlsWrapper" class="controls-wrapper">
        <div class="text-input-container">
            <textarea id="text" placeholder="Enter your text here..."></textarea>
        </div>

        <div class="controls-container">
            <div class="controls flex-row">
                <div class="flex-column flex6 align-flex-end">
                    <div class="flex-row">
                        <label for="fontSize">Font size:</label>
                        <input type="number" id="fontSize" min="8" max="24" value="15" step="0.1">
                    </div>

                    <div class="flex-row">
                        <label for="transpose">Transpose:</label>
                        <input type="number" id="transpose" min="-12" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="colorfulChords">Colorful chords:</label>
                        <input type="checkbox" id="colorfulChords" value="true" checked>
                    </div>

                    <div class="flex-row">
                        <label for="originalNoteNames">Original note names:</label>
                        <input type="checkbox" id="originalNoteNames" value="true">
                    </div>

                    <div class="flex-row">
                        <label for="useNashvilleNotation">Nashville notation:</label>
                        <input type="checkbox" id="useNashvilleNotation" value="true">
                    </div>
                </div>

                <div class="flex-column flex6 align-flex-end">
                    <div class="flex-row">
                        <label for="padding">Padding:</label>
                        <input type="number" id="padding" min="0" max="99" step="5" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="capo">Capo:</label>
                        <input type="number" id="capo" min="0" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="colorfulHeaders">Colorful headers:</label>
                        <input type="checkbox" id="colorfulHeaders" value="true" checked>
                    </div>

                    <div class="flex-row">
                        <label for="stylizeAccidentals">Stylize accidentals:</label>
                        <input type="checkbox" id="stylizeAccidentals" value="true">
                    </div>

                    <div class="flex-row">
                        <label for="castMode" id="castModeLabel">Is casting:</label>
                        <input type="checkbox" id="castMode" value="true">
                        <button id="exitCastModeButton" class="hidden" type="button">Stop Cast Mode</button>
                    </div>
                </div>

                <div class="flex-column flex10 align-flex-end">
                    <div class="flex-row">
                        <label for="preferredAccidental">Preferred accidental:</label>
                        <select id="preferredAccidental">
                            <option value="auto" selected>Auto</option>
                            <option value="#">#</option>
                            <option value="b">b</option>
                        </select>
                    </div>

                    <div class="flex-row">
                        <label for="capoAsWritten">Written with capo:</label>
                        <input type="number" id="capoAsWritten" min="0" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="prettyTablatures">Pretty tablatures:</label>
                        <input type="checkbox" id="prettyTablatures" value="true" checked>
                    </div>

                    <div class="flex-row">
                        <label for="useAccidentalsFromKey">Use accidentals from key:</label>
                        <input type="checkbox" id="useAccidentalsFromKey" value="true" checked>
                    </div>

                    <div class="flex-row">
                        <button id="hideAndFitButton" type="button">Hide & Fit</button>
                        <button id="hideButton" type="button">Hide</button>
                    </div>
                </div>
            </div>

            <div id="detectedKey" class="detected-key"></div>

            <div class="keyboard-shortcuts">
                Keyboard shortcuts:
                <strong>h</strong> - toggle controls,
                <strong>n</strong> - decrease font,
                <strong>m</strong> - increase font,
                <strong>f</strong> - fit text,
                <strong>v</strong> - use Nashville notation
            </div>
        </div>
    </div>

    <div id="contentWrapper" class="content-wrapper">
        <div id="contentContainer" class="content-container">
            <div id="leftEdgePixelAnchor"></div>
            <div id="content"></div>
            <div id="rightEdgePixelAnchor"></div>
        </div>
    </div>

    <div id="castModeOverlay" class="cast-mode-overlay hidden">
        <div class="card">
            <div class="title" id="projectionOverlayTitle"></div>
            <div class="description">You can display these chords on the television. When you send them to the television the current window will be closed.</div>
            <button id="castButton" type="button">Show on TV</button>
        </div>
    </div>

    <div id="newSongInfoOverlay" class="new-song-info-overlay hidden">
        <div class="modal">
            <div class="info">New Song Loaded</div>
            <div id="newSongInfoTitle" class="title"></div>
            <div id="newSongInfoArtist" class="artist"></div>
        </div>
    </div>

    <script id="utilityFunctions">
        function debounce(func, wait = 50) {
            let timeout = null;

            return function() {
                if (!timeout) {
                    timeout = setTimeout(() => timeout = null, wait);
                    func.apply(this, arguments);
                }
            };
        }

        function generateGUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0; // random integer between 0 and 15
                const v = c === 'x' ? r : (r & 0x3 | 0x8); // bitwise operations to handle 'y' and 'x'
                return v.toString(16);
            });
        }

        function repeatPeriodically(count, timeout, func) {
            const intervalHandle = setInterval(() => {
                count--;
                try {
                    if (func(count) || count <= 0) {
                        clearInterval(intervalHandle);
                    }
                } catch {
                    clearInterval(intervalHandle);
                }
            }, timeout);

            return intervalHandle;
        }

        function getHashParam(param) {
            if (!window.location.hash) {
                return null;
            }

            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            return hashParams.get(param);
        }

        function setHash(value) {
            if (history.replaceState) {
                history.replaceState(undefined, undefined, '#' + (value ?? ''));
            } else {
                window.location.replace('#' + (value ?? ''));
            }
        }

        function setHashParam(param, value) {
            const hashParams = new URLSearchParams(window.location.hash && window.location.hash.substring(1) || '');
            if (value == undefined) {
                hashParams.delete(param);
            } else {
                hashParams.set(param, value);
            }

            setHash(hashParams.toString());
        }

        function readCookie(name)  {
            const cookie = document.cookie;
            const cookies = cookie.split("; ");
            for (const cookie of cookies) {
                const [cookieName, cookieValue] = cookie.split('=');
                if (cookieName === name) {
                    return decodeURIComponent(cookieValue);
                }
            }

            return undefined;
        }

        function localStorageAccessor(key) {
            return {
                get: () => window.localStorage.getItem(key),
                set: value => window.localStorage.setItem(key, value),
                remove: () => window.localStorage.removeItem(key),
                exists: () => window.localStorage.getItem(key) != undefined
            }
        }

        function writeCookie(name, value, options = {}) {
            const {
                daysToExpire = null,
                path = '/',
                domain = '',
                secure = false,
                sameSite = 'Lax'
            } = options;

            let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

            if (daysToExpire !== null) {
                const expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() + daysToExpire);
                cookieString += `; expires=${expirationDate.toUTCString()}`;
            }

            cookieString += `; path=${path}`;

            if (domain) {
                cookieString += `; domain=${domain}`;
            }

            if (secure) {
                cookieString += '; secure';
            }

            cookieString += `; SameSite=${sameSite}`;

            document.cookie = cookieString;
        }

        function getValueFromCookieDb(cookieStorageName) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                if (cookieValue != undefined) {
                    const jsonCookieValue = JSON.parse(cookieValue);
                    return jsonCookieValue[keyName];
                }
            } catch {
                console.error(`Error reading value from cookie: ${cookieStorageName}`);
            }

            return undefined;
        }

        function setValueInCookieDb(cookieStorageName, value) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                const jsonCookieValue = cookieValue != undefined ? JSON.parse(cookieValue) : {};
                jsonCookieValue[keyName] = value;
                writeCookie(cookieName, JSON.stringify(jsonCookieValue));
            } catch {
                console.error(`Error writing value to cookie: ${cookieStorageName}`);
            }
        }

        function compare(x, y) {
            return x < y ? -1 :
                   x > y ? 1 :
                   0;
        }

        function isDigit(str) {
            return str && str.length == 1 && str >= '0' && str <= '9';
        }

        function toString(value) {
            return value == undefined ? '' : `${value}`;
        }

        function floatToString(value, precision) {
            return value == undefined ? '' : value.toFixed(precision);
        }

        function toFloat(value) {
            const result = parseFloat(value);
            return isNaN(result) ? undefined : result;
        }

        function roundFloat(value, precision) {
            return Number(Math.round(value + 'e' + precision) + 'e-' + precision);
        }

        function toBoolean(value) {
            return value === true || value === 'true';
        }

        function isEmpty(str) {
            return str == undefined || str === '';
        }

        function isWhitespace(str) {
            return str == undefined || str.trim() === '';
        }

        function createElement(elementName, className, style) {
            const el = document.createElement(elementName);

            if (Array.isArray(className)) {
                el.className = className.filter(v => !!v).join(" ");
            } else if (className) {
                el.className = className;
            }

            if (style) {
                for (const [key, value] of Object.entries(style)) {
                    el.style[key] = value;
                }
            }

            return el;
        }

        function elementSize(element, options = {}) {
            function parsePixels(styleValue) {
                return styleValue ? parseFloat(styleValue) : 0;
            }

            const {includeMargin = true, includePadding = true} = options;

            const boundingRect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);

            return {
                width: boundingRect.width +
                       (includeMargin ? parsePixels(style.marginLeft) + parsePixels(style.marginRight) : 0) +
                       (includePadding ? 0 : -parsePixels(style.paddingLeft) - parsePixels(style.paddingRight)),

                height: boundingRect.height +
                        (includeMargin ? parsePixels(style.marginTop) + parsePixels(style.marginBottom) : 0) +
                        (includePadding ? 0 : -parsePixels(style.paddingTop) - parsePixels(style.paddingBottom)),
            }
        }

        function encodeHtml(str) {
            if (!str) {
                return '';
            };

            const el = createElement('div');
            el.textContent = str;
            return el.innerHTML;
        }

        function encodeAttr(str) {
            if (!str) {
                return '';
            };

            const el = createElement('div');
            el.setAttribute('attr', str);

            // Find out whether the browser used single or double quotes before encodedText
            const quote = el.outerHTML[el.outerHTML.search(/['"]/)];
            // Split up the generated HTML using the quote character; take item 1
            return el.outerHTML.split(new RegExp(quote))[1];
        }

        function applyClass(element, condition, className) {
            if (condition) {
                element.classList.add(className);
            } else {
                element.classList.remove(className);
            }
        }

        function renderElementToString(elementName, renderIfEmpty, content, className) {
            let shouldEncode = true;

            if (typeof content === 'function') {
                content = content();
                shouldEncode = false;
            }


            if (!renderIfEmpty && isEmpty(content)) {
                return '';
            }

            content = content ?? '';

            if (Array.isArray(className)) {
                className = className.filter(v => !!v).join(" ");
            } else if (!className) {
                className = '';
            }

            return `<${elementName}${isWhitespace(className) ? '' : ` class="${className}"`}>${shouldEncode ? encodeHtml(content) : content}</${elementName}>`;
        }

        function span(content, className) {
            return renderElementToString('span', false, content, className);
        }

        function th(content, className) {
            return renderElementToString('th', true, content, className);
        }

        function td(content, className) {
            return renderElementToString('td', true, content, className);
        }

        function charSpans(content) {
            if (!content) {
                return '';
            }

            return Array.from(content)
                        .map(c => `<span class="char" content="${encodeAttr(c)}">${encodeHtml(c)}</span>`)
                        .join('')
        }

        function rgx(optionArg, ...args) {
            if (typeof optionArg === 'string' || optionArg instanceof String) {
                return createRegex({name: optionArg}, args);
            } else if (optionArg instanceof RegExp || Array.isArray(optionArg)) {
                return createRegex({}, [optionArg, ...args]);
            } else if (typeof optionArg === 'object') {
                return createRegex(optionArg, args);
            } else {
                throw new Error("Unsupported type of option parameter");
            }

            function createRegex(options, regexes) {
                let regexStr = regexes.length === 1 ? processRegex(regexes[0]).source
                                                    : regexes.map(regex => `(${processRegex(regex).source})`)
                                                             .join('');
                regexStr = nameAndQuantify(options, regexStr);
                return new RegExp(regexStr, options.flags);
            }

            function createDisjunction(regexArray) {
                return new RegExp(regexArray.map(regex => processRegex(regex).source).join('|'));
            }

            function processRegex(regex) {
                if (regex instanceof RegExp) {
                    return regex;
                } else if (Array.isArray(regex)) {
                    return createDisjunction(regex);
                } else {
                    throw new Error("Only regexes and arrays are supported");
                }
            }

            function nameAndQuantify(options, regexStr) {
                if (options.repeat?.count != undefined || options.repeat?.min != undefined || options.repeat?.max != undefined) {
                    const exactQuantifier = options.repeat?.count != undefined
                        ? `{${options.count}}`
                        : `{${toString(options.repeat.min)},${toString(options.repeat.max)}}`;

                    regexStr = `(${regexStr})${exactQuantifier}`;
                    options = {...options, repeat: false};
                }

                const quantifier = options.repeat ? (options.optional ? '*' : '+')
                                                  : (options.optional ? '?' : '');

                if (options.name && options.repeat) {
                    // we need to put the repeat quantifier inside the named capture group
                    return `(?<${options.name}>(${regexStr})${quantifier})`;
                }

                return options.name ? `(?<${options.name}>${regexStr})${quantifier}`
                                    : `(${regexStr})${quantifier}`;
            }
        }

        rgx.of = function(optionArg, str) {
            if (optionArg == undefined && str == undefined) {
                throw new Error("Invalid arguments");
            } else if (str == undefined) {
                str = optionArg;
                optionArg = {};
            } else if (typeof optionArg === 'string' || optionArg instanceof String) {
                optionArg = {name: optionArg};
            }

            return rgx(optionArg, new RegExp(RegExp.escape(str)));
        };

        rgx.ofCaseInsensitive = function(optionArg, str) {
            if (optionArg == undefined && str == undefined) {
                throw new Error("Invalid arguments");
            } else if (str == undefined) {
                str = optionArg;
                optionArg = {};
            } else if (typeof optionArg === 'string' || optionArg instanceof String) {
                optionArg = {name: optionArg};
            }

            const pattern = Array.from(str)
                                 .map(c => c.toUpperCase() != c.toLowerCase()
                                               ? `[${RegExp.escape(c.toUpperCase())}${RegExp.escape(c.toLowerCase())}]`
                                               : RegExp.escape(c))
                                 .join('');

            return rgx(optionArg, new RegExp(pattern));
        };

        rgx.chars = function(optionArg, characters) {
            if (optionArg == undefined && characters == undefined) {
                throw new Error("Invalid arguments");
            } else if (characters == undefined) {
                characters = optionArg;
                optionArg = {};
            } else if (typeof optionArg === 'string' || optionArg instanceof String) {
                optionArg = {name: optionArg};
            }

            characters = characters.replaceAll(/\s+/g, '');
            const pattern = characters.length == 1 && !optionArg.whitespace
                ? RegExp.escape(characters)
                : `[${optionArg.whitespace ? '\\s' : ''}${RegExp.escape(characters)}]`;
            return rgx(optionArg, new RegExp(pattern));
        };

        rgx.lookAhead = function(...regexes) {
            return new RegExp(`(?=${rgx(...regexes).source})`);
        }

        rgx.lookBehind = function(...regexes) {
            return new RegExp(`(?<=${rgx(...regexes).source})`);
        }

        function matchAll(str, regex) {
            if (str == undefined) {
                return [];
            }

            regex = new RegExp(regex.source, regex.flags.includes("g") ? regex.flags : regex.flags + "g");
            return Array.from(str.matchAll(regex));
        }

        function matchFirst(str, regex) {
            const matches = matchAll(str, regex);
            if (matches.length == 0) {
                return undefined;
            }

            return matches[0];
        }

        function testRegex(str, regex) {
            return !!matchFirst(str, regex);
        }

        function fragmentize(str, regex) {
            const matches = matchAll(str, regex);

            const fragments = [];
            let fragmentizedLength = 0;

            for (const match of matches) {
                const matchedSubstring = str.substring(match.index, match.index + match[0].length);

                if (match.index > fragmentizedLength) {
                    const unmatchedSubstring = str.substring(fragmentizedLength, match.index);
                    fragments.push({text: unmatchedSubstring, index: fragmentizedLength, isMatch: false});
                }

                fragments.push({text: matchedSubstring, index: match.index, isMatch: true, groups: match.groups});
                fragmentizedLength = match.index + matchedSubstring.length;
            }

            if (str.length > fragmentizedLength) {
                const unmatchedSubstring = str.substring(fragmentizedLength);
                fragments.push({text: unmatchedSubstring, index: fragmentizedLength, isMatch: false});
            }

            return fragments;
        }

        function bindData(bindings, onChange, parse, stringify) {
            let {el, hash, cookie, followHashDeletion} = bindings;

            const identifier = el && (el.name || el.id);
            if (hash === true && identifier) {
                hash = identifier;
            }
            if (cookie === true && identifier) {
                cookie = "db:" + identifier;
            }

            let typeSpecificMethods = {};

            if (el && el.nodeName == 'INPUT' && el.type == 'checkbox') {
                parse = parse ?? toBoolean;
                stringify = stringify ?? toString;

                typeSpecificMethods = {
                    toggle: function() {
                        this.set(!this.get());
                    }
                }
            } else if (el && el.nodeName == 'INPUT' && el.type == 'number') {
                const stepAttr = el.step || '1';
                const [whole, decimal] = stepAttr.split('.');
                const precision = decimal ? decimal.length : 0;

                parse = parse ?? toFloat;
                stringify = stringify ?? (v => floatToString(v, precision));

                typeSpecificMethods = {
                    min: toFloat(el.min),
                    max: toFloat(el.max),
                    step: toFloat(stepAttr),
                    precision: precision,

                    increase: function() {
                        const newValue = roundFloat(this.get() + this.step, this.precision);
                        if (this.max == undefined || newValue <= this.max) {
                            this.set(newValue)
                        }
                    },

                    decrease: function() {
                        const newValue = roundFloat(this.get() - this.step, this.precision);
                        if (this.min == undefined || newValue >= this.min) {
                            this.set(newValue)
                        }
                    }
                }
            } else {
                parse = parse ?? (value => value ?? '');
                stringify = stringify ?? (value => value ?? '');
            }

            let currentValue = parse('');

            function loadFromUrl() {
                const value = getHashParam(hash);

                if (followHashDeletion || value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function loadFromCookie() {
                const value = getValueFromCookieDb(cookie)

                if (value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function isCheckbox(element) {
                return element.nodeName === 'INPUT' && element.type === 'checkbox';
            }

            function loadFromElement() {
                const rawValue = isCheckbox(el) ? (el.checked ? el.value : '')
                                                : el.value;
                const parsedValue = parse(rawValue);

                if (parsedValue !== currentValue) {
                    currentValue = parsedValue;
                    return true;
                }

                return false;
            }

            function updateUrl() {
                if (hash) {
                    const existingHashValue = getHashParam(hash);
                    const stringifiedCurrentValue = stringify(currentValue);

                    if (!existingHashValue || stringifiedCurrentValue !== existingHashValue) {
                        setHashParam(hash, stringifiedCurrentValue);
                    }
                }
            }

            function updateCookie() {
                if (cookie) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    setValueInCookieDb(cookie, stringifiedCurrentValue);
                }
            }

            function updateElement() {
                if (el) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    if (el.nodeName === 'INPUT' && el.type === 'checkbox') {
                        el.checked = el.value === stringifiedCurrentValue;
                    } else {
                        el.value = stringifiedCurrentValue;
                    }
                }
            }

            if (el) {
                const eventName = isCheckbox(el) ? 'click' : 'input';

                el.addEventListener(eventName, event => {
                    const previousValue = currentValue;
                    if (loadFromElement()) {
                        onChange(currentValue, previousValue, undefined, event);
                        if (!event.defaultPrevented) {
                            updateUrl();
                            updateCookie();
                        } else {
                            currentValue = previousValue;
                        }
                    }
                });
            }

            if (hash) {
                window.addEventListener('hashchange', () => {
                    const previousValue = currentValue;
                    if (loadFromUrl()) {
                        updateElement();
                        updateCookie();
                        onChange(currentValue, previousValue);
                    }
                });
            }

            if (hash && getHashParam(hash) != undefined) {
                loadFromUrl();
                updateElement();
            } else if (cookie && getValueFromCookieDb(cookie) != undefined) {
                loadFromCookie();
                updateElement();
            } else if (el) {
                loadFromElement();
            }

            return {
                get: () => currentValue,

                set: (value, additionalData) => {
                    const previousValue = currentValue;
                    currentValue = value;
                    updateElement();
                    updateUrl();
                    updateCookie();
                    onChange(currentValue, previousValue, additionalData);
                },

                setElementValueSilently: value => {
                    currentValue = value;
                    updateElement();
                },

                hasHashParam: () => hash && getHashParam(hash) != undefined,

                clearHashParam: () => {
                    if (hash) {
                        setHashParam(hash, undefined);
                    }
                },

                ...typeSpecificMethods
            }
        }

        function getEffectiveTextAreaSelection(element) {
            return element.selectionDirection == 'backward' ?
                {start: element.selectionEnd, end: element.selectionStart} :
                {start: element.selectionStart, end: element.selectionEnd};
        }

        function setTextAreaSelection(element, start, end) {
            const currentSelection = getEffectiveTextAreaSelection(element);
            start = start ?? currentSelection.start;
            end = end ?? currentSelection.end;

            element.selectionStart = Math.min(start, end);
            element.selectionEnd = Math.max(start, end);
            element.selectionDirection = start < end ? 'forward' :
                                         start > end ? 'backward' :
                                         'none';
        }

        function getStartOfLinePositionForTextAreaCaret(element) {
            const selectionEnd = getEffectiveTextAreaSelection(element).end;
            const previousLineEnd = element.value.lastIndexOf("\n", selectionEnd - 1);
            return previousLineEnd >= 0 ? previousLineEnd + 1 : 0;
        }

        function getEndOfLinePositionForTextAreaCaret(element) {
            const selectionEnd = getEffectiveTextAreaSelection(element).end;
            const lineEnd = element.value.indexOf("\n", selectionEnd);
            return lineEnd >= 0 ? lineEnd : element.value.length;
        }

        function findFloorUsingStepBinarySearch(low, high, step, precision, computeFunc, comparisonFunc) {
            let result = undefined;

            while (low <= high) {
                const mid = roundFloat(low + Math.floor((high - low) / 2 / step) * step, precision);
                const value = computeFunc(mid);
                const comparisonResult = comparisonFunc(value);

                if (comparisonResult <= 0) {
                    result = value;
                    low = roundFloat(mid + step, precision);
                } else {
                    high = roundFloat(mid - step, precision);
                }
            }

            return result;
        }
    </script>

    <script id="domainFunctions">
        function mod(value, modValue) {
            if (value == undefined) {
                return undefined;
            }

            value %= modValue;
            if (value < 0) {
                value += modValue;
            }

            return value;

        }

        function transp(degree, transpose) {
            if (degree == undefined) {
                return undefined;
            }

            return mod(degree + transpose, 12);
        }

        function parallelMinorOfMajorKey(keyDegree) {
            return transp(keyDegree, 3);
        }

        function parallelMajorOfMajorKey(keyDegree) {
            return transp(keyDegree, -3);
        }

        function relativeMinorOfMajorKey(keyDegree) {
            return transp(keyDegree, -3);
        }

        function relativeMajorOfMinorKey(keyDegree) {
            return transp(keyDegree, 3);
        }

        function normalizeAccidentals(note) {
           return note.replaceAll('‚ôØ', '#').replaceAll('‚ô≠', 'b');
        }

        const regexes = (function() {
            const noteNames = /(C|D|E|F|G|A|B|H)(‚ôØ|#|b|‚ô≠){0,2}/;

            const musicalSymbols = '. ‚Ä¶ ‚Ä• ‚Ä§ ‚Äæ¬Ø ^‚åÉŒî‚ñ≤‚è∂ -‚èú‚èù‚ó†‚ó°‚åí‚å£ ‚¨≠‚¨¨ ‚óá‚¨¶‚ô¢‚óÜ‚ô¶ ‚ô©‚ô™ùÑê êíá‚åá‚ñ¨‚¨ì‚¨í ‚ë†‚ë°‚ë£‚ëß‚ëØ‚ù∂‚ù∑‚ùπ‚ùΩ‚ì∞';
            const beatSymbols = '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ‚Å∫‚Åª‚Åº ‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ‚Çä‚Çã‚Çå ‚Ä¢‚ñÆ ‚ñö ‚ñØ ‚ó´‚éÖ ‚ãà‚ßì';

            const parenthesizedContent = /\([^\)]+\)/;
            const bracedContent = /\{[^\}]+\}/;
            const fingering = /(\d|x){4,7}/;

            const chord = rgx([/^/, rgx.lookBehind(rgx.chars({whitespace: true}, '|()-‚ï∂}‚ï¥‚èú‚èù‚ó†‚ó°‚åí‚å£'))],
                              rgx.chars({name: "prefix", optional: true}, '‚§∫·ëâ~<>'),
                              rgx({name: "chordName"},
                                  [rgx.of('N.C.'),
                                  /%/,
                                  /X/,
                                  rgx(rgx("root", noteNames),
                                      rgx({name: "variant", optional: true},
                                          [/(maj7|M7|7)?(?<isSuspended>sus)(2|4)?/,
                                           /(?<isDiminished>dim|¬∞|√∏)7?/, // ¬∞ is diminished, √∏ is half-diminished
                                           /(?<isAugmented>aug)7?/,
                                           /M/,
                                           /(?<isPower>5)/,
                                           rgx(/(?<isMinor>m|min)?/,
                                               /(2|4|6|((maj|M)?(7|9|11|13)))?/,
                                               rgx({optional: true},
                                                   [/(?<hasFlatFifth>b5|‚ô≠5)/, /‚ôØ5|#5/, /(‚ôØ|#|b|‚ô≠)9/, /add(‚ôØ|#|b|‚ô≠)?(9|11|13)/]))
                                          ]),
                                      rgx({optional: true}, rgx.of('/'), rgx("bass", noteNames)))
                                  ]),
                              rgx.chars({name: "suffix", optional: true, repeat: true}, beatSymbols + musicalSymbols),
                              [/$/, rgx.lookAhead(rgx.chars({whitespace: true}, '|()-‚ï∂{‚ï¥‚èú‚èù‚ó†‚ó°‚åí‚å£,:*'))],
                              rgx('whitespace', /\s*/))

            return {
                chord,
                allowedWithChords: rgx([parenthesizedContent, bracedContent, fingering, rgx.chars({whitespace: true}, '|%:*()-[]‚èú‚èù‚ó†‚ó°‚åí‚å£')]),
                tablature: rgx({flags: 'i'},
                               /^(?<pre>\s*)/,
                               rgx('tablature',
                                   noteNames, rgx.of('|'), rgx.chars({repeat: {min: 4}}, '-‚îÄ|/\\()^~*0123456789hspxvb'), rgx.of('|')),
                               /$|(?<post>\s.*)$/),
                tablatureTiming: rgx({flags: 'u'},
                                     /^(?<pre>\s*)/,
                                     rgx('tablature',
                                         rgx.chars('‚ßñ‚è≤ùÑû'), rgx.of('|'), rgx.chars({whitespace: true, repeat: {min: 4}}, '|' + musicalSymbols), rgx.of('|')),
                                     /$|(?<post>\s.*)$/),
                title: /\[(?<title>[^\]]+)\]/,
                metadata: /\{(?<metadata>[^\}]+)\}/,
                chordLegend: rgx(/^\s*/, chord, /(:|\s)\s*/, fingering, /\s*$/),

                capoMetadataFragment: rgx(rgx('capoPrefix', rgx.ofCaseInsensitive('Capo'), /(:|\s)\s*/),
                                          /(?<capo>\d+)/,
                                          rgx({name: 'capoSuffix', optional: true},
                                              rgx({optional: true},
                                                  [rgx.ofCaseInsensitive('st'),
                                                   rgx.ofCaseInsensitive('nd'),
                                                   rgx.ofCaseInsensitive('rd'),
                                                   rgx.ofCaseInsensitive('th')]),
                                              rgx.ofCaseInsensitive({optiona: true}, ' fret'))),

                keyMetadataFragment: rgx(rgx('keyPrefix',
                                             [rgx.ofCaseInsensitive('Key'),
                                              rgx.ofCaseInsensitive('Key change'),
                                              rgx.ofCaseInsensitive('Back to key')],
                                             /(:|\s)\s*/),
                                         rgx("keyName", noteNames),
                                         rgx.ofCaseInsensitive({name: 'isMinor', optional: true}, 'm'))
            }
        })();

        const noteChart = (function() {
            function keyAccidental(keyName, preferredAccidental) {
                return keyName == 'C' ? (preferredAccidental ?? 'auto') :
                       keyName == 'F' ? 'b' :
                       keyName.includes('b') ? 'b' :
                       '#';
            }

            function totalAccidentalValue(noteName) {
                noteName = normalizeAccidentals(noteName);
                return noteName.split('#').length - noteName.split('b').length;
            }

            function stripAccidentals(noteName) {
                return normalizeAccidentals(noteName).replaceAll('b', '').replaceAll('#', '');
            }

            const wholeNoteDegrees = {'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11};
            const majorScaleDegrees = [0, null, 1, null, 2, 3, null, 4, null, 5, null, 6];

            const notes = {
                '#':        ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                'b':        ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'],
                'auto':     ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'],
                'keyNames': ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'],
                'numerals': ['1', 'b2', '2', 'b3', '3', '4', 'b5', '5', 'b6', '6', 'b7', '7'],
                'whole':    Object.keys(wholeNoteDegrees)
            };

            return {
                getNoteDegree: function(noteName) {
                    const correction = totalAccidentalValue(noteName);

                    noteName = stripAccidentals(noteName);
                    if (noteName == 'H') {
                        noteName = 'B';
                    }

                    return wholeNoteDegrees[noteName] != undefined
                        ? transp(wholeNoteDegrees[noteName], correction)
                        : undefined;
                },

                getNoteByDegree: function(degree, preferredAccidental) {
                    return notes[preferredAccidental ?? 'auto'][degree];
                },

                walkMajorScale: function (fromMajorScaleDegree, toMajorScaleDegree, startingNote) {
                    const startingNoteDegree = this.getNoteDegree(startingNote);
                    const startingWholeNote = stripAccidentals(startingNote);
                    const startingWholeNoteMajorScaleDegree = majorScaleDegrees[wholeNoteDegrees[startingWholeNote]];

                    const resultWholeNote = notes.whole[mod(startingWholeNoteMajorScaleDegree + toMajorScaleDegree - fromMajorScaleDegree, 7)];
                    const resultDegree = this.getNoteDegree(resultWholeNote);

                    const targetDegree = transp(startingNoteDegree,
                                                wholeNoteDegrees[notes.whole[toMajorScaleDegree]] - wholeNoteDegrees[notes.whole[fromMajorScaleDegree]]);

                    const correction1 = targetDegree - resultDegree;
                    const correction2 = (12 - Math.abs(correction1)) * -Math.sign(correction1);
                    const correction = Math.abs(correction1) < Math.abs(correction2) ? correction1 : correction2;

                    return resultWholeNote + (correction > 0 ? '#' : 'b').repeat(Math.abs(correction));
                },

                getNoteByDegreeAndKey: function(noteDegree, keyNameOrDegree, preferredAccidental) {
                    const [keyName, keyDegree] =
                        typeof keyNameOrDegree === 'string' || keyNameOrDegree instanceof String
                            ? [keyNameOrDegree, this.getNoteDegree(keyNameOrDegree)]
                            : [notes.keyNames[keyNameOrDegree], keyNameOrDegree];

                    const noteDegreeRelativeToKey = transp(noteDegree, -keyDegree);
                    const majorScaleDegree = majorScaleDegrees[noteDegreeRelativeToKey];

                    if (majorScaleDegree != undefined) {
                        return this.walkMajorScale(0, majorScaleDegree, keyName);
                    }

                    let lower = this.walkMajorScale(0, majorScaleDegrees[transp(noteDegreeRelativeToKey, -1)], keyName);
                    let higher = this.walkMajorScale(0, majorScaleDegrees[transp(noteDegreeRelativeToKey, 1)], keyName);

                    lower = totalAccidentalValue(lower) < 0 ? lower.replace('b', '') : lower + '#';
                    higher = totalAccidentalValue(higher) > 0 ? higher.replace('#', '') : higher + 'b';

                    return lower.length < higher.length ? lower :
                           higher.length < lower.length ? higher :
                           notes[keyAccidental(keyName, preferredAccidental)][noteDegree];
                },

                getNumeral(noteDegree, keyDegree) {
                    return notes.numerals[transp(noteDegree, -keyDegree)];
                },

                getKeyName(keyDegree) {
                    return notes.keyNames[keyDegree];
                }
            };
        })();

        const noteRenderer = (function() {
            function shouldUseOriginalNoteName(key, transpose, noteNamingConfig) {
                return noteNamingConfig.originalNoteNames && transpose == 0;
            }

            return {
                getNoteName: function(note, key, transposeConfig, noteNamingConfig) {
                    const transpose = transposeConfig?.effectiveTransposition() ?? 0;

                    if (shouldUseOriginalNoteName(key, transpose, noteNamingConfig)) {
                        if (note.noteName) {
                            return note.noteName;
                        }

                        if (key.keyName) {
                            const keyName = noteChart.walkMajorScale(key.isMinor ? 5 : 0, 0, key.keyName);
                            return noteChart.getNoteByDegreeAndKey(note.noteDegree, keyName, noteNamingConfig.preferredAccidental)
                        }
                    }

                    const noteDegree = transp(note.noteDegree, transpose);
                    if (key && noteNamingConfig.useAccidentalsFromKey) {
                        const keyDegree = transp(key.keyDegree, transpose);
                        return noteChart.getNoteByDegreeAndKey(noteDegree, keyDegree, noteNamingConfig.preferredAccidental);
                    }

                    return noteChart.getNoteByDegree(noteDegree, noteNamingConfig.preferredAccidental);
                },

                getKeyName: function(key, transposeConfig, noteNamingConfig) {
                    const transpose = transposeConfig?.effectiveTransposition() ?? 0;

                    if (shouldUseOriginalNoteName(key, transpose, noteNamingConfig) && key.keyName) {
                        return noteChart.walkMajorScale(key.isMinor ? 5 : 0, 0, key.keyName);
                    }

                    const keyDegree = transp(key.keyDegree, transpose);
                    return noteNamingConfig.useAccidentalsFromKey
                                ? noteChart.getKeyName(keyDegree)
                                : noteChart.getNoteByDegree(keyDegree, noteNamingConfig.preferredAccidental);
                },

                getRelativeMinorKeyName: function(key, transposeConfig, noteNamingConfig) {
                    const transpose = transposeConfig?.effectiveTransposition() ?? 0;

                    if (shouldUseOriginalNoteName(key, transpose, noteNamingConfig) && key.keyName) {
                        return noteChart.walkMajorScale(0, key.isMinor ? 0 : 5, key.keyName) + "m";
                    }

                    const keyDegree = transp(key.keyDegree, transpose);
                    const keyName = noteNamingConfig.useAccidentalsFromKey
                                        ? noteChart.getNoteByDegreeAndKey(relativeMinorOfMajorKey(keyDegree), keyDegree, noteNamingConfig.preferredAccidental)
                                        : noteChart.getNoteByDegree(relativeMinorOfMajorKey(keyDegree), noteNamingConfig.preferredAccidental);
                    return keyName + 'm';
                }
            };
        })();

        function processChord(chord, transposeConfig, noteNamingConfig) {
            function processNote(noteName) {
                const noteDegree = noteChart.getNoteDegree(noteName);
                if (chord.key && !chord.isChordLegend && noteNamingConfig.useNashvilleNotation) {
                    return noteChart.getNumeral(noteDegree, chord.key.keyDegree);
                }

                return noteRenderer.getNoteName({noteDegree, noteName}, chord.key, chord.isChordLegend ? undefined : transposeConfig, noteNamingConfig);
            }

            if (!chord.root) {
                return {chordName: chord.chordName, key: chord.key};
            }

            const root = processNote(chord.root);
            const bass = chord.bass ? processNote(chord.bass) : '';
            const bassSeparator = bass ? '/' : '';

            let variant = chord.variant ? normalizeAccidentals(chord.variant) : '';
            let variantSeparator = '';

            if (isDigit(root.slice(-1))) {
                if (variant == '5') {
                    variant = '‚ö°';
                } else if (isDigit(variant.slice(0, 1))) {
                    // other variant separator candidates: ·îã ·ëâ ·ïØ ‚Üë ‚≠° ‚¨Ü ü†â ‚â∫ ‚¶â ‚å© ‚≠ç ‚ÜØ ‚ö° üé∏ ü™´ üîå
                    variantSeparator = '‚≠°';
                }
            }

            return {
                chordName: root + variantSeparator + variant + bassSeparator + bass,
                root,
                variant,
                variantSeparator,
                bass,
                bassSeparator,
                key: chord.key
            };
        }

        function spanifyFragment(line, fragment, transposeConfig, noteNamingConfig) {
            function spanifyMetadataSubFragment(subFragment) {
                if (subFragment.type === 'metadata.key') {
                    const keyName = subFragment.data.isMinor
                                        ? noteRenderer.getRelativeMinorKeyName(subFragment.data, transposeConfig, noteNamingConfig)
                                        : noteRenderer.getKeyName(subFragment.data, transposeConfig, noteNamingConfig)

                    return subFragment.data.keyPrefix +
                           span(() => charSpans(keyName), 'metadata-key-name');
                }

                if (subFragment.type === 'metadata.capo') {
                    if (transposeConfig.capo == subFragment.data.capoValue) {
                        return subFragment.text;
                    }

                    const capoValue = transposeConfig.capo ? transposeConfig.capo : 'No capo';
                    return subFragment.data.capoPrefix + capoValue;
                }

                return encodeHtml(subFragment.text);
            }

            if (fragment.type === 'metadata') {
                return span(() => span('{', 'brace') +
                                  span(() => fragment.data.subFragments.map(spanifyMetadataSubFragment).join(''), 'metadata') +
                                  span('}', 'brace'),
                            'metadata-container');
            }

            if (fragment.type === 'title') {
                return span(() => span('[', 'bracket') +
                                  span(fragment.data.title, 'title') +
                                  span(']', 'bracket'),
                            'title-container');
            }

            if (fragment.type == 'tablature') {
                return span(fragment.data.pre, 'tablature-pre') +
                       span(() => charSpans(fragment.data.tablature), 'tablature') +
                       span(fragment.data.post, 'tablature-post');
            }

            if (fragment.type == 'chord') {
                const chord = processChord(fragment.data, transposeConfig, noteNamingConfig);

                let whitespace = fragment.data.whitespace ?? '';
                const lengthDiff = chord.chordName.length - fragment.data.chordName.length;

                if (lengthDiff < 0) {
                    whitespace += ' '.repeat(-lengthDiff);
                } else if (lengthDiff > 0 && whitespace.length >= 1) {
                    // can remove all whitespace if followed by a bar that's not the last character in the line
                    const nextCharIndex = fragment.index + fragment.text.length;
                    const canRemoveAllWhitespace = line.text[nextCharIndex] == '|' &&
                                                   nextCharIndex < line.text.length - 1;

                    whitespace = whitespace.substring(canRemoveAllWhitespace
                                                        ? lengthDiff
                                                        : Math.min(lengthDiff, whitespace.length - 1));
                }

                return span(() => span(() => charSpans(fragment.data.prefix), 'chord-prefix') +
                                  span(() => span(() => charSpans(chord.root ?? chord.chordName), 'chord-name') +
                                             span(() => charSpans(chord.variantSeparator), 'variant-separator') +
                                             span(() => charSpans(chord.variant), 'variant') +
                                             span(() => charSpans(chord.bassSeparator), 'bass-separator') +
                                             span(() => charSpans(chord.bass), 'bass'),
                                       ['chord', chord.key && noteNamingConfig.useNashvilleNotation && 'nashville']) +
                                  span(() => charSpans(fragment.data.suffix), 'chord-suffix'),
                            'chord-container') + whitespace;
            }

            return encodeHtml(fragment.text).replaceAll('|', charSpans);
        }

        function createLineHtmlElement(line, transposeConfig, noteNamingConfig) {
            const element = createElement('div', ['line',
                                                  line.chords.length > 0 && 'has-any-chords',
                                                  line.is('whitespace') && 'empty-line',
                                                  line.is('header') && 'header-line',
                                                  line.is('tablature') && 'tablature-line',
                                                  line.is('tablatureTiming') && 'tablature-timing-line',
                                                  line.nextLine?.is('tablature') && 'followed-by-tablature-line',
                                                  line.nextLine?.is('header') && 'followed-by-header-line',
                                                  line.nextLine?.is('tablatureTiming') && 'followed-by-tablature-timing-line']);

            if (line.is('whitespace')) {
                element.innerHTML = "<br>"
            } else {
                element.innerHTML = line.fragments && line.fragments.length
                                        ? line.fragments.map(f => spanifyFragment(line, f, transposeConfig, noteNamingConfig)).join('')
                                        : encodeHtml(line.text);
            }

            return element;
        }

        function detectKey(parsedLines) {
            function isChordInKey(keyDegree, chord) {
                const chordsInKey = ['major', null, 'minor', null, 'minor', 'major', null, 'major', null, 'minor', null, 'diminished'];
                const relativeChordDegree = transp(chord.chordDegree, -keyDegree);

                return chordsInKey[relativeChordDegree] &&
                       (chordsInKey[relativeChordDegree] == chord.variant ||
                        ((chord.variant == 'suspended' || chord.variant == 'power') && chordsInKey[relativeChordDegree] != 'diminished'));
            }

            function chordScoreForKey(keyDegree, chord) {
                if (isChordInKey(keyDegree, chord)) {
                    return 0;
                }

                if (isChordInKey(parallelMinorOfMajorKey(keyDegree), chord) ||
                    isChordInKey(parallelMajorOfMajorKey(keyDegree), chord)) {
                    return -1;
                }

                return -3;
            }

            function goodFirstChordForKeyScoreBump(chordInfo, keyDegree) {
                if (firstChordInfo.variant == "major" && keyDegree == firstChordInfo.chordDegree) {
                    return 5;
                }

                if (firstChordInfo.variant == 'minor' && keyDegree == relativeMajorOfMinorKey(firstChordInfo.chordDegree)) {
                    return 4;
                }

                if(firstChordInfo.variant == "suspended" || firstChordInfo.variant == "power") {
                    if (keyDegree == firstChordInfo.chordDegree) {
                        return 4;
                    }

                    if (keyDegree == relativeMajorOfMinorKey(firstChordInfo.chordDegree)) {
                        return 2;
                    }
                }

                return 0;
            }

            const chordsInSong = {};
            let firstChordInfo = undefined;

            for (const line of parsedLines) {
                for (const chord of line.chords) {
                    if (!chord.root || chord.isAugmented || chord.isChordLegend) {
                        continue;
                    }

                    const variant = (chord.isDiminished || chord.hasFlatFifth) ? 'diminished' :
                                    chord.isSuspended ? 'suspended' :
                                    chord.isPower ? 'power' :
                                    chord.isMinor ? 'minor' :
                                    'major';

                    const chordDegree = noteChart.getNoteDegree(chord.root);
                    const chordStr = `${chordDegree}_${variant}`;
                    const chordInfo = chordsInSong[chordStr] ?? (chordsInSong[chordStr] = {chordDegree, variant, count: 0});
                    chordInfo.count++;

                    if (!firstChordInfo) {
                        firstChordInfo = chordInfo;
                    }
                }
            }

            const keyMatches = [];
            for (let keyDegree = 0; keyDegree < 12; keyDegree++) {
                keyMatches.push({
                    keyDegree,
                    initialChordScoreBump: firstChordInfo ? goodFirstChordForKeyScoreBump(firstChordInfo, keyDegree) : 0,
                    score: Object.values(chordsInSong)
                                 .reduce((score, chord) => score + chordScoreForKey(keyDegree, chord) * chord.count, 0)
                });
            }

            keyMatches.sort((a, b) => compare(b.score + b.initialChordScoreBump, a.score + a.initialChordScoreBump));

            console.log("Key detection performed",
                        keyMatches.length > 0
                          ? keyMatches.map(m => noteRenderer.getKeyName({keyDegree: m.keyDegree}, undefined, {useAccidentalsFromKey: true}) +
                                                ` (Relative minor: ${noteRenderer.getRelativeMinorKeyName({keyDegree: m.keyDegree}, undefined, {useAccidentalsFromKey: true})})` +
                                                `, Total score: ${m.score + m.initialChordScoreBump}` +
                                                `, Chord score: ${m.score}` +
                                                (`, Initial chord score bump: ${m.initialChordScoreBump}`))
                          : "No key matches");

            return keyMatches[0] ? {keyDegree: keyMatches[0].keyDegree, isDetected: true} : undefined;
        }

        function parseLines(text) {
            function isHeaderLine(line) {
                const nothingButTitleOrMetadata = rgx(/^\s*/,
                                                      rgx({repeat: true}, [regexes.title, regexes.metadata], /\s*/),
                                                      /$/);

                return !isWhitespace(line) && testRegex(line, nothingButTitleOrMetadata);
            }

            function isTablatureTiming(line) {
                return !isWhitespace(line) && !isHeaderLine(line) && testRegex(line, regexes.tablatureTiming);
            }

            function isTablatureLine(line) {
                return !isWhitespace(line) && !isHeaderLine(line) && (testRegex(line, regexes.tablature) || isTablatureTiming(line));
            }

            function isChordLegendLine(line) {
                return !isWhitespace(line) && testRegex(line, regexes.chordLegend);
            }

            function isChordLine(line) {
                if (isWhitespace(line) || isTablatureLine(line) || isHeaderLine(line)) {
                    return false;
                }

                const nothingButChordsRegex = rgx(/^/,
                                                  rgx({repeat: true, optional: true}, regexes.allowedWithChords),
                                                  rgx({repeat: true},
                                                      regexes.chord,
                                                      rgx({repeat: true, optional: true}, regexes.allowedWithChords)),
                                                  /$/);
                return testRegex(line, nothingButChordsRegex);
            }

            function isTextLine(line) {
                return !isWhitespace(line) && !isChordLine(line) && !isHeaderLine(line) && !isTablatureLine(line);
            }

            function shouldChordify(parsedLine) {
                return parsedLine.is('chords') || (parsedLine.is('text') && matchAll(parsedLine.text, regexes.chord).length >= 2);
            }

            function splitLines(text) {
                const lines = text.split('\n');
                const result = [];

                for (let i = 0; i < lines.length; i++) {
                    if (isWhitespace(lines[i])) {
                        // if two empty lines precede header line, keep only one
                        if (isWhitespace(lines[i + 1]) && isHeaderLine(lines[i + 2])) {
                            continue;
                        }

                        // remove up to two empty lines after a header line,
                        // but keep one empty line if it is between two header lines
                        if (isHeaderLine(lines[i - 1]) && !isHeaderLine(lines[i + 1]) ||
                            isWhitespace(lines[i - 1]) && isHeaderLine(lines[i - 2])) {
                            continue;
                        }
                    }

                    result.push(lines[i].trimEnd()); // Trim whitespace from the end of each line

                    // enforce one empty line before a header line
                    if (!isWhitespace(lines[i]) && isHeaderLine(lines[i + 1])) {
                        result.push('');
                    }
                };

                // Remove empty lines at the end of the text
                while (result.length > 0 && isWhitespace(result[result.length - 1])) {
                    result.pop();
                }

                return result;
            }

            function createMetadataSubFragments(metadataText, onKeyDetected) {
                const fragmentPartsRegex = rgx(rgx.lookBehind(/(^|,)\s*/),
                                               rgx.lookAhead(/[^\s,]/),
                                               [regexes.keyMetadataFragment, regexes.capoMetadataFragment, /[^,]+/],
                                               rgx.lookBehind(/[^\s,]/),
                                               rgx.lookAhead(/\s*(,|$)/));

                const subFragments = [];
                const metadataParts = fragmentize(metadataText, fragmentPartsRegex);

                for (const part of metadataParts) {
                    if (part.isMatch && part.groups.keyName) {
                        let keyDegree = noteChart.getNoteDegree(part.groups.keyName);
                        if (part.groups.isMinor) {
                            keyDegree = relativeMajorOfMinorKey(keyDegree);
                        }

                        onKeyDetected({keyDegree, ...part.groups});

                        subFragments.push({
                            type: 'metadata.key',
                            text: part.text,
                            index: part.index,
                            data: {keyDegree, ...part.groups}
                        });
                    } else if (part.isMatch && part.groups.capo) {
                        subFragments.push({
                            type: 'metadata.capo',
                            text: part.text,
                            index: part.index,
                            data: {capoValue: toFloat(part.groups.capo) ?? 0, ...part.groups}
                        });
                    } else {
                        subFragments.push({
                            type: part.isMatch ? 'metadata.other' : 'metadata.text',
                            text: part.text,
                            index: part.index,
                            data: {}
                        });
                    }
                }

                return subFragments;
            }

            const lines = splitLines(text);

            const result = [];
            let currentKey = undefined;

            for (let i = 0; i < lines.length; i++) {
                const text = lines[i];

                const parsedLine = {
                    text: text,
                    fragments: [],
                    chords: [],
                    metadataEntries: [],

                    tags: [
                        isWhitespace(text) && 'whitespace',
                        isHeaderLine(text) && 'header',
                        isChordLegendLine(text) && 'chordLegend',
                        isTablatureLine(text) && 'tablature',
                        isTablatureTiming(text) && 'tablatureTiming',
                        isChordLine(text) && 'chords',
                        isTextLine(text) && 'text'
                    ].filter(v => !!v),

                    is: function(tag) {
                        return this.tags.includes(tag);
                    }
                };

                if (parsedLine.is('header')) {
                    const titleOrMetadataRegex = rgx([regexes.title, regexes.metadata]);
                    const fragments = fragmentize(text, titleOrMetadataRegex);

                    for (const fragment of fragments) {
                        if (fragment.isMatch && fragment.groups?.metadata) {
                            const subFragments = createMetadataSubFragments(fragment.groups.metadata, key => currentKey = key);
                            parsedLine.metadataEntries = subFragments.filter(sf => sf.type !== 'metadata.text');
                            parsedLine.fragments.push({
                                type: 'metadata',
                                text: fragment.text,
                                index: fragment.index,
                                data: {...fragment.groups, subFragments}
                            });
                        } else if (fragment.isMatch && fragment.groups?.title) {
                            parsedLine.fragments.push({
                                type: 'title',
                                text: fragment.text,
                                index: fragment.index,
                                data: {...fragment.groups}
                            });
                        } else {
                            parsedLine.fragments.push({
                                type: 'text',
                                text: fragment.text,
                                index: fragment.index,
                                data: {}
                            });
                        }
                    }
                } else if (parsedLine.is('tablature')) {
                    const matchGroups = matchFirst(text, parsedLine.is('tablatureTiming') ? regexes.tablatureTiming : regexes.tablature).groups;
                    parsedLine.fragments.push({
                        type: 'tablature',
                        text: text,
                        index: 0,
                        data: {pre: matchGroups.pre, tablature: matchGroups.tablature, post: matchGroups.post}
                    });
                } else if (shouldChordify(parsedLine)) {
                    const chordOrMetadataRegex = rgx([regexes.metadata, regexes.chord]);
                    const fragments = fragmentize(text, chordOrMetadataRegex);

                    for (const fragment of fragments) {
                        if (fragment.isMatch && fragment.groups?.metadata) {
                            const subFragments = createMetadataSubFragments(fragment.groups.metadata, key => currentKey = key);
                            parsedLine.metadataEntries = subFragments.filter(sf => sf.type !== 'metadata.text');
                            parsedLine.fragments.push({
                                type: 'metadata',
                                text: fragment.text,
                                index: fragment.index,
                                data: {...fragment.groups, subFragments}
                            });
                        } else if (fragment.isMatch && fragment.groups?.chordName) {
                            const chord = {...fragment.groups, key: currentKey, isChordLegend: parsedLine.is('chordLegend')};
                            parsedLine.chords.push(chord);
                            parsedLine.fragments.push({
                                type: 'chord',
                                text: fragment.text,
                                index: fragment.index,
                                data: chord
                            });
                        } else {
                            parsedLine.fragments.push({
                                type: 'text',
                                text: fragment.text,
                                index: fragment.index,
                                data: {}
                            });
                        }
                    }
                }

                result.push(parsedLine);
                if (i > 0) {
                    result[i - 1].nextLine = parsedLine;
                    parsedLine.previousLine = result[i - 1];
                }
            }

            // Perform key detection if needed
            if (currentKey == undefined) {
                result.detectedKey = detectKey(result);
                for (const parsedLine of result) {
                    for (const chord of parsedLine.chords) {
                        chord.key = result.detectedKey;
                    }
                }
            }

            return result;
        }

        function inferCapoFromText(parsedLines) {
            for (const line of parsedLines) {
                for (const metadataEntry of line.metadataEntries) {
                    if (metadataEntry.type === 'metadata.capo') {
                        return metadataEntry.data.capoValue;
                    }
                }
            }

            return 0;
        }
    </script>

    <script id="domAndDataManipulationFunctions">
        function createNashvilleLegend(lines, transposeConfig, noteNamingConfig) {
            const usedNotes = lines.flatMap(line => line.chords)
                                   .filter(chord => chord.key && chord.root && !chord.isChordLegend)
                                   .flatMap(chord => chord.bass
                                               ? [{noteName: chord.root, key: chord.key}, {noteName: chord.bass, key: chord.key}]
                                               : [{noteName: chord.root, key: chord.key}])
                                   .map(note => {
                                       return {
                                           noteName: note.noteName,
                                           noteDegree: noteChart.getNoteDegree(note.noteName),
                                           relativeNoteDegree: transp(noteChart.getNoteDegree(note.noteName), -note.key.keyDegree),
                                           key: note.key
                                       };
                                   });

            const usedKeys = new Map();
            for (const note of usedNotes) {
                let keyWithNotes = usedKeys.get(note.key.keyDegree);
                if (!keyWithNotes) {
                    keyWithNotes = {key: note.key, notes: new Map()};
                    usedKeys.set(note.key.keyDegree, keyWithNotes);
                }

                if (!keyWithNotes.notes.get(note.relativeNoteDegree)) {
                    keyWithNotes.notes.set(note.relativeNoteDegree, note);
                }
            }

            if (usedKeys.size == 0) {
                return undefined;
            }

            const usedRelativeNoteDegrees = new Set(usedNotes.map(note => note.relativeNoteDegree)
                                                             .sort(compare));

            let header = '<th class="empty"></th>';
            for (const relativeNoteDegree of usedRelativeNoteDegrees) {
                const isMajorScaleDegree = noteChart.getNoteByDegree(relativeNoteDegree).length == 1;
                header += th(() => span(() => charSpans(noteChart.getNumeral(relativeNoteDegree, 0))),
                             ['nashville-numeral',
                             isMajorScaleDegree && 'major-degree']);
            }

            let data = ''
            for (const keyWithNotes of usedKeys.values()) {
                const keyName = noteRenderer.getKeyName(keyWithNotes.key, transposeConfig, noteNamingConfig);
                const relativeMinorKeyName = noteRenderer.getRelativeMinorKeyName(keyWithNotes.key, transposeConfig, noteNamingConfig);

                data += '<tr>';
                data += `<th class="key-name">${charSpans(keyName)}(${charSpans(relativeMinorKeyName)})</th>`;

                for (const relativeNoteDegree of usedRelativeNoteDegrees) {
                    const isMajorScaleDegree = noteChart.getNoteByDegree(relativeNoteDegree).length == 1;

                    const note = keyWithNotes.notes.get(relativeNoteDegree);
                    if (!note) {
                        data += td('', isMajorScaleDegree && 'major-degree');
                        continue;
                    }

                    const noteName = noteRenderer.getNoteName(note, keyWithNotes.key, transposeConfig, noteNamingConfig);
                    data += td(() => span(() => charSpans(noteName), 'note'), isMajorScaleDegree && 'major-degree');
                }

                data += '</tr>'
            }

            const legendElement = createElement('div', ['line', 'nashville-legend']);
            legendElement.innerHTML = `<table><tr>${header}</tr>${data}</table>`;
            return legendElement;
        }

        function redrawContent(lines, fontSize, transposeConfig, noteNamingConfig) {
            doc.content.innerHTML = '';
            doc.content.style.fontSize = fontSize + 'px';

            const availableHeight = elementSize(doc.content, {includePadding: false, includeMargin: false}).height;

            const lineElements = lines.map(line => createLineHtmlElement(line, transposeConfig, noteNamingConfig));

            const columns = [];
            let currentColumn = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                const lineElement = lineElements[i];
                const nextLineElement = lineElements[i + 1];

                let lineFitsCurrentColumn = false;

                if (currentColumn) {
                    currentColumn.div.appendChild(lineElement);
                    let requiredHeight = elementSize(lineElement).height;

                    if (line.is('chords') && line.nextLine?.is('text')) {
                        currentColumn.div.appendChild(nextLineElement);
                        requiredHeight += elementSize(nextLineElement).height;
                        currentColumn.div.removeChild(nextLineElement);
                    }

                    lineFitsCurrentColumn = currentColumn.height + requiredHeight <= availableHeight;

                    if (!lineFitsCurrentColumn) {
                        if (line.is('whitespace')) {
                            lineElement.classList.add('overflow-y-hidden');
                        } else {
                            currentColumn.div.removeChild(lineElement);
                        }
                    } else {
                        currentColumn.width = Math.max(currentColumn.width, elementSize(lineElement).width);
                        currentColumn.height += elementSize(lineElement).height;
                    }
                }

                if (!lineFitsCurrentColumn) {
                    if (line.is('whitespace')) {
                        continue;
                    }

                    const newColumnDiv = createElement('div', 'column', {position: 'absolute', visibility: 'hidden'});
                    doc.content.appendChild(newColumnDiv);

                    // Render Nashville legend if needed
                    const nashvilleLegend = !currentColumn && noteNamingConfig.useNashvilleNotation
                                                ? createNashvilleLegend(lines, transposeConfig, noteNamingConfig)
                                                : undefined;

                    if (nashvilleLegend) {
                        newColumnDiv.appendChild(nashvilleLegend);
                    }
                    newColumnDiv.appendChild(lineElement);

                    currentColumn = {
                        div: newColumnDiv,
                        width: Math.max(elementSize(lineElement).width, nashvilleLegend ? elementSize(nashvilleLegend).width : 0),
                        height: elementSize(lineElement).height + (nashvilleLegend ? elementSize(nashvilleLegend).height : 0)
                    };

                    columns.push(currentColumn);
                }
            }

            for (const column of columns) {
                column.div.style.width = column.width + 'px';
                column.div.style.position = '';
                column.div.style.visibility = '';
            };

            return elementSize(doc.content).width;
        }

        function redraw(considerRefitting) {
            const minTextLengthForAutoFitting = 100;
            const maxFontSizeForAutoFitting = 21;

            const lines = data.getParsedLines();

            const noteNamingConfig = {
                preferredAccidental: data.preferredAccidental.get(),
                useNashvilleNotation: data.useNashvilleNotation.get(),
                useAccidentalsFromKey: data.useAccidentalsFromKey.get(),
                originalNoteNames: data.originalNoteNames.get()
            };

            const transposeConfig = {
                transpose: data.transpose.get() ?? 0,
                capo: data.capo.get() ?? 0,
                capoAsWritten: data.capoAsWritten.get() ?? 0,

                effectiveTransposition: function() {
                    return this.transpose - this.capo + this.capoAsWritten;
                }
            }

            const shouldRefit = considerRefitting &&
                                data.text.get() && data.text.get().length >= minTextLengthForAutoFitting &&
                                !data.fontSize.hasHashParam();

            doc.contentWrapper.classList.remove('polished');

            doc.contentWrapper.style.padding = `${data.padding.get()}px 0px`;
            doc.contentWrapper.style.margin = `0px ${data.padding.get()}px`;

            applyClass(doc.content, data.colorfulChords.get(), 'colorful-chords');
            applyClass(doc.content, data.colorfulHeaders.get(), 'colorful-headers');
            applyClass(doc.content, data.stylizeAccidentals.get(), 'stylize-accidentals');
            applyClass(doc.content, data.prettyTablatures.get(), 'pretty-tablatures');

            if (lines.detectedKey != undefined) {
                const keyName = noteRenderer.getKeyName(lines.detectedKey, transposeConfig, noteNamingConfig);
                const relativeMinorKeyName = noteRenderer.getRelativeMinorKeyName(lines.detectedKey, transposeConfig, noteNamingConfig);
                doc.detectedKey.innerHTML = `Detected key: <strong>${keyName}</strong> (relative minor: <strong>${relativeMinorKeyName}</strong>)`
            } else {
                doc.detectedKey.innerHTML = '';
            }

            if (shouldRefit) {
                fullscreen.withTemporaryFullscreen(() => {
                    const defaultFontSize = data.fontSize.get();

                    const availableWidth = elementSize(doc.contentContainer, {includePadding: false, includeMargin: false}).width -
                                           elementSize(doc.leftEdgePixelAnchor).width -
                                           elementSize(doc.rightEdgePixelAnchor).width;

                    const result = findFloorUsingStepBinarySearch(
                        data.fontSize.min,
                        Math.min(data.fontSize.max, maxFontSizeForAutoFitting),
                        data.fontSize.step,
                        data.fontSize.precision,
                        fontSize => ({fontSize, contentWidth: redrawContent(lines, fontSize, transposeConfig, noteNamingConfig)}),
                        value => compare(value.contentWidth, availableWidth));

                    data.fontSize.setElementValueSilently(result?.fontSize ?? defaultFontSize);
                });
            }

            redrawContent(lines, data.fontSize.get(), transposeConfig, noteNamingConfig);

            doc.contentWrapper.classList.add('polished');
        }

        function updateTitle() {
            const title = data.title.get()?.trim() ?? '';

            if (title) {
                let artist = data.artist.get()?.trim() ?? '';
                if (testRegex(artist, /, The$/i)) {
                    artist = `The ${data.artist.get().replace(/, The$/i, '')}`;
                }

                const fullName = artist ? `${title} - ${artist}` : title;

                document.title = fullName;
                doc.projectionOverlayTitle.textContent = fullName;
                doc.newSongInfoTitle.textContent = title;
                doc.newSongInfoArtist.textContent = artist;
            } else {
                document.title = 'Chord Projector';
                doc.projectionOverlayTitle.textContent = '';
                doc.newSongInfoTitle.textContent = '';
                doc.newSongInfoArtist.textContent = '';
            }
        }

        function inferCapo() {
            if (!data.capoAsWritten.hasHashParam()) {
                const inferredCapo = inferCapoFromText(data.getParsedLines());
                data.capoAsWritten.setElementValueSilently(inferredCapo);
                if (!data.capo.hasHashParam()) {
                    data.capo.setElementValueSilently(inferredCapo);
                }
            }
        }

        const showNewSongModal = (function() {
            let newSongModalTimeoutHandle = undefined;

            return function() {
                if (newSongModalTimeoutHandle) {
                    clearTimeout(newSongModalTimeoutHandle);
                }

                doc.newSongInfoOverlay.classList.remove('hidden', 'visible', 'hiding');

                setTimeout(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            doc.newSongInfoOverlay.classList.add('visible');

                            newSongModalTimeoutHandle = setTimeout(() => {
                                doc.newSongInfoOverlay.classList.remove('visible');
                                doc.newSongInfoOverlay.classList.add('hiding');

                                setTimeout(() => {
                                    doc.newSongInfoOverlay.classList.add('hidden');
                                    doc.newSongInfoOverlay.classList.remove('hiding');
                                }, 1900);
                            }, 7000);
                        });
                    });
                }, 700);
            }
        })();

        const fullscreen = {
            isFullScreen: () => document.body.classList.contains('fullscreen'),

            enable: value => {
                applyClass(document.body, value, 'fullscreen');
                redraw(value);
            },

            withTemporaryFullscreen: function(action) {
                const wasFullscreen = this.isFullScreen();
                document.body.classList.add('fullscreen');

                try {
                    action();
                } finally {
                    applyClass(document.body, wasFullscreen, 'fullscreen');
                }
            }
        }

        const instanceManager = (function() {
            let projectionOfferIntervalHandle = undefined;

            const local = {
                mainInstance: localStorageAccessor('instances.mainInstance'),
                offeredForProjection: localStorageAccessor('offeredForProjection')
            }

            function getInstanceName() {
                try {
                    const existingWindowName = window.sessionStorage.getItem("instanceName");
                    if (existingWindowName) {
                        return existingWindowName;
                    }

                    const guid = generateGUID();
                    window.sessionStorage.setItem("instanceName", guid);
                    return guid;
                } catch {
                    return generateGUID();
                }
            }

            function reinitializeData(dataBinding, value, defaultValue) {
                dataBinding.clearHashParam();
                if (value != undefined) {
                    dataBinding.set(value);
                } else {
                    dataBinding.setElementValueSilently(defaultValue);
                }
            }

            return {
                isMainInstance: () => {
                    return getInstanceName() == local.mainInstance.get();
                },

                exitCastMode: function() {
                    local.mainInstance.remove();
                    this.applyVisuals();
                },

                applyVisuals: function() {
                    doc.favicon.href = this.isMainInstance() ? 'favicon-cast.svg' : 'favicon-browse.svg';
                    doc.castButton.disabled = !data.text.get();
                    applyClass(doc.castModeOverlay, this.isMainInstance() || !local.mainInstance.exists(), 'hidden');
                    applyClass(doc.exitCastModeButton, this.isMainInstance() || !local.mainInstance.exists(), 'hidden');
                    applyClass(doc.castMode, !this.isMainInstance() && local.mainInstance.exists(), 'hidden');
                    applyClass(doc.castModeLabel, !this.isMainInstance() && local.mainInstance.exists(), 'hidden');
                },

                initialize: function() {
                    data.castMode.setElementValueSilently(this.isMainInstance());
                    this.applyVisuals();
                },

                mainInstanceChanged: function(value) {
                    if (value) {
                        local.mainInstance.set(getInstanceName());
                    } else if (this.isMainInstance()) {
                        this.exitCastMode();
                    }

                    this.applyVisuals();
                },

                onStorageChanged: function() {
                    if (!this.isMainInstance()) {
                        data.castMode.setElementValueSilently(false);
                        this.applyVisuals();
                        return;
                    }

                    if (local.offeredForProjection.exists()) {
                        const offeredForProjection = JSON.parse(local.offeredForProjection.get());
                        local.offeredForProjection.remove();

                        if (Date.now() - offeredForProjection.timestamp > 1000) {
                            return;
                        }

                        history.pushState(undefined, undefined);

                        reinitializeData(data.transpose, offeredForProjection.transpose, 0);
                        reinitializeData(data.capo, offeredForProjection.capo, 0);
                        reinitializeData(data.capoAsWritten, offeredForProjection.capoAsWritten, 0);
                        reinitializeData(data.useNashvilleNotation, offeredForProjection.useNashvilleNotation, false);

                        data.fontSize.clearHashParam();

                        data.text.set(offeredForProjection.text, {refit: true});
                        data.title.set(offeredForProjection.title);
                        data.artist.set(offeredForProjection.artist);

                        fullscreen.enable(true);

                        showNewSongModal();
                    }
                },

                offerForProjection: function() {
                    if (!data.text.get()) {
                        return;
                    }

                    if (projectionOfferIntervalHandle != undefined) {
                        clearInterval(projectionOfferIntervalHandle);
                    }

                    local.offeredForProjection.set(JSON.stringify({
                        timestamp: Date.now(),

                        text: data.text.get(),
                        title: data.title.get(),
                        artist: data.artist.get(),

                        transpose: data.transpose.hasHashParam() ? data.transpose.get() : undefined,
                        capo: data.capo.hasHashParam() ? data.capo.get() : undefined,
                        capoAsWritten: data.capoAsWritten.hasHashParam() ? data.capoAsWritten.get() : undefined,
                        useNashvilleNotation: data.useNashvilleNotation.hasHashParam() ? data.useNashvilleNotation.get() : undefined
                    }));

                    projectionOfferIntervalHandle = repeatPeriodically(20, 20, count => {
                        if (!local.offeredForProjection.exists()) {
                            window.close();

                            setTimeout(() => {
                                document.body.innerHTML = '<h3>This window could not be closed automatically due to browser restrictions.</h3><div>Your chords have been successfully sent for casting, but you will need to close this window manually.</div>';
                            }, 100);

                            return true;
                        }

                        if (count == 0) {
                            local.offeredForProjection.remove();
                        }
                    });
                }
            };
        })();
    </script>

    <script id="dataBindings">
        const doc = {};
        document.querySelectorAll('[id]').forEach(element => doc[element.id] = element);

        const data = {
            text: bindData({el: doc.text, hash: true, followHashDeletion: true}, (_, previousValue, additionalData) => {
                inferCapo();
                instanceManager.applyVisuals();
                redraw(!previousValue || additionalData?.refit);
            }),
            fontSize: bindData({el: doc.fontSize, hash: true, followHashDeletion: true}, value => redraw(!value)),
            transpose: bindData({el: doc.transpose, hash: true}, () => redraw()),
            capo: bindData({el: doc.capo, hash: true}, () => redraw()),
            capoAsWritten: bindData({el: doc.capoAsWritten, hash: true}, () => redraw()),
            preferredAccidental: bindData({el: doc.preferredAccidental, hash: true, cookie: true}, () => redraw()),
            colorfulChords: bindData({el: doc.colorfulChords, hash: true, cookie: true}, () => redraw()),
            colorfulHeaders: bindData({el: doc.colorfulHeaders, hash: true, cookie: true}, () => redraw()),
            padding: bindData({el: doc.padding, hash: true, cookie: true}, () => redraw()),
            useNashvilleNotation: bindData({el: doc.useNashvilleNotation, hash: true, cookie: true}, () => redraw(true)),
            stylizeAccidentals: bindData({el: doc.stylizeAccidentals, hash: true, cookie: true}, () => redraw()),
            useAccidentalsFromKey: bindData({el: doc.useAccidentalsFromKey, hash: true, cookie: true}, () => redraw()),
            prettyTablatures: bindData({el: doc.prettyTablatures, hash: true, cookie: true}, () => redraw()),
            originalNoteNames: bindData({el: doc.originalNoteNames, hash: true, cookie: true}, () => redraw()),
            castMode: bindData({el: doc.castMode}, (value, _, __, event) => {
                if (!event || value || !instanceManager.isMainInstance() || confirm("Are you sure you want to exit casting mode?")) {
                    instanceManager.mainInstanceChanged(value);
                } else {
                    event.preventDefault();
                }
            }),
            title: bindData({hash: 'title', followHashDeletion: true}, () => updateTitle()),
            artist: bindData({hash: 'artist', followHashDeletion: true}, () => updateTitle()),

            getParsedLines: (function() {
                let cacheKey = undefined;
                let cachedValue = undefined;

                return function() {
                    if (this.text.get() !== cacheKey) {
                        cacheKey = this.text.get();
                        cachedValue = parseLines(this.text.get());
                    }

                    return cachedValue;
                }
            })()
        };
    </script>

    <script id="eventListenersSetup">
        window.addEventListener('resize', () => redraw());

        // Add keyboard shortcuts
        document.addEventListener('keydown', debounce(e => {
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }

            const anyInputHasFocus = Array.from(document.querySelectorAll('input, textarea'))
                                          .some(item => document.activeElement === item)

            if (anyInputHasFocus) {
                return;
            }

            switch(e.key.toLowerCase()) {
                case 'h': { // Toggle controls visibility
                    fullscreen.enable(!fullscreen.isFullScreen());
                    break;
                }

                case 'f': { // Hide controls, if visible, and fit text to screen
                    data.fontSize.clearHashParam();
                    fullscreen.enable(true);
                    break;
                }

                case 'n': { // Decrease font size
                    data.fontSize.decrease();
                    break;
                }

                case 'm': { // Increase font size
                    data.fontSize.increase();
                    break;
                }

                case 'v': { // Toggle Nashville notation
                    data.useNashvilleNotation.toggle();
                    break;
                }
            }
        }));

        doc.hideButton.addEventListener('click', () => {
            fullscreen.enable(true);
        });

        doc.hideAndFitButton.addEventListener('click', () => {
            data.fontSize.clearHashParam();
            fullscreen.enable(true);
        });

        doc.contentContainer.addEventListener('dblclick', () => {
            if (fullscreen.isFullScreen()) {
                fullscreen.enable(false);
            }
        });

        document.body.addEventListener('paste', e => {
            if (fullscreen.isFullScreen()) {
                const text = (e.clipboardData || window.clipboardData).getData("text");
                if (text && text != data.text.get()) {
                    data.text.set(text, {refit: true});
                    e.preventDefault();
                }
            }
        });

        doc.text.addEventListener('keydown', e => {
            switch(e.key.toLowerCase()) {
                case 'home': {
                    const startOfLine = getStartOfLinePositionForTextAreaCaret(event.target)
                    setTextAreaSelection(event.target, event.shiftKey ? undefined : startOfLine, startOfLine);
                    e.preventDefault();
                    break;
                }

                case 'end': {
                    const endOfLine = getEndOfLinePositionForTextAreaCaret(event.target);
                    setTextAreaSelection(event.target, event.shiftKey ? undefined : endOfLine, endOfLine);
                    e.preventDefault();
                    break;
                }
            }
        });

        doc.exitCastModeButton.addEventListener('click', () => {
            if (confirm("Are you sure you want to exit casting mode?")) {
                instanceManager.exitCastMode()
            }
        });

        doc.castButton.addEventListener('dblclick', e => e.stopPropagation());

        doc.castButton.addEventListener('click', () => instanceManager.offerForProjection());

        window.addEventListener('storage', () => instanceManager.onStorageChanged());

        window.addEventListener('beforeunload', e => {
            if (instanceManager.isMainInstance()) {
                e.preventDefault();
                e.returnValue = true; // Included for legacy support, e.g. Chrome/Edge < 119
            }
        });

        if ("IntersectionObserver" in window &&
            "IntersectionObserverEntry" in window &&
            "intersectionRatio" in window.IntersectionObserverEntry.prototype) {

            new IntersectionObserver(entries => applyClass(doc.contentContainer, !entries[0].isIntersecting, 'has-horizontal-overflow-left'))
                .observe(doc.leftEdgePixelAnchor);

            new IntersectionObserver(entries => applyClass(doc.contentContainer, !entries[0].isIntersecting, 'has-horizontal-overflow-right'))
                .observe(doc.rightEdgePixelAnchor);
        }
    </script>

    <script id="main">
        if (!window.location.hash && !window.location.href.endsWith('#')) {
            setHash();
        }

        updateTitle();
        instanceManager.initialize();

        if (data.text.get()) {
            inferCapo();
            fullscreen.enable(true); // this will also redraw

            if (instanceManager.isMainInstance()) {
                showNewSongModal();
            }
        }
    </script>
</body>
</html>