<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Projector</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            overflow: hidden; /* Prevents scrolling on the body */
        }

        body {
            display: flex;
            flex-direction: column;
            padding: 10px;
            font-size: 15px; /* Default size that will be configurable */
            box-sizing: border-box;
        }

        .controls-wrapper {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin-bottom: 10px;
            display: flex;
            gap: 20px;
        }

        .text-input-container {
            flex: 2; /* Takes 2/3 of the space */
        }

        .controls-container {
            flex: 1; /* Takes 1/3 of the space */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .controls {
            margin-bottom: 10px;
            font-size: 12px;
        }

        .controls label {
            display: inline-block;
            margin-top: 3px;
        }

        .controls input {
            width: 50px;
        }

        .controls input.whole-number {
            width: 40px;
        }

        .controls input[type="checkbox"] {
            width: 13px;
        }

        .controls input, .controls select {
            margin-top: 3px;
            margin-right: 15px;
        }

        .keyboard-shortcuts {
            margin-top: auto;
            font-size: 12px;
            color: #666;
        }

        textarea {
            width: 100%;
            height: 100%;
            resize: none;
            box-sizing: border-box;
        }

        .overflow-y-hidden {
            overflow-y: hidden;
        }

        .container {
            flex: 1;
            display: flex;
            position: relative;
            width: 100%;
            box-sizing: border-box;
            margin-top: 10px;
            border: 1px solid #ddd;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden; /* No vertical scrolling */
        }

        .container.fullscreen {
            margin-top: 0;
            border: none;
        }

        #content {
            display: flex;
            flex-shrink: 0;
        }

        .column {
            flex-shrink: 0;
            position: relative;
            margin-right: 20px;
            padding-right: 10px;
        }

        .has-horizontal-overflow-right::after {
            content: '';
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0px;
            width: 25px;
            background: linear-gradient(.25turn, transparent, rgba(255,0,0,0.1) 40%, rgba(255,0,0,0.5) 80%);
            pointer-events: none;
            z-index: 1;
        }

        .has-horizontal-overflow-left::before {
            content: '';
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0px;
            width: 25px;
            background: linear-gradient(to left, transparent, rgba(255,0,0,0.1) 40%, rgba(255,0,0,0.5) 80%);
            pointer-events: none;
            z-index: 1;
        }

        /* column separator */
        .column:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 1px;
            background-color: #ccc;
            z-index: 0;
        }

        .column:last-child {
            margin-right: 0;
            padding-right: 0;
        }

        .line {
            font-family: 'Roboto Mono', 'Courier New', monospace;
            line-height: 1.3; /* Tighter line spacing */
            margin: 0;
            padding: 0;
            white-space: pre; /* Preserves whitespace including multiple spaces */
            text-overflow: clip; /* Clips text that doesn't fit */
        }

        .line .chord {
            font-weight: 700;
            background-color: rgb(232, 232, 232);
            border-radius: 3px;
            margin-left: -.13em;
            padding-left: .13em;
            margin-right: -.13em;
            padding-right: .13em;
        }

        .colorful-chords .line .chord {
            color: rgb(0, 123, 255);
            background-color: rgb(240, 248, 255);
        }

        .line.empty-line {
            line-height: 1;
        }

        .line.empty-line.pre-header-line + .line.header-line{
            margin-top: -0.3em;
        }

        .line.header-line {
            padding-bottom: 0.4em;
        }

        .line.header-line > span {
            background-color: rgb(232, 232, 232);
            border-radius: 5px;
        }

        .line.header-line .wh {
            display:none;
        }

        .colorful-headers .line.header-line > span {
            background-color: rgb(238, 229, 242);
        }

        .colorful-headers .line.header-line .title {
            font-size: 0.98em;
            letter-spacing: 1px;
        }

        .colorful-headers .line.header-line .bracket {
            font-size: 0.6em;
            color: rgb(232, 232, 232);
        }

        #left-edge-pixel-anchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }

        #right-edge-pixel-anchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="controls-wrapper" id="controls-wrapper">
        <div class="text-input-container">
            <textarea id="input-text" placeholder="Enter your text here..."></textarea>
        </div>

        <div class="controls-container">
            <div class="controls">
                <label for="font-size">Font size (px):</label>
                <input type="number" id="font-size" min="8" max="20" value="15" step="0.2">

                <label for="preferred-accidental">Preferred accidental:</label>
                <select id="preferred-accidental">
                  <option value="#" selected>#</option>
                  <option value="♯">♯ (stylized)</option>
                  <option value="b">b</option>
                  <option value="♭">♭ (stylized)</option>
                </select>

                <br>

                <label for="transpose">Transpose:</label>
                <input type="number" id="transpose" min="-12" max="12" value="0">

                <label for="capo">Capo:</label>
                <input class="whole-number" type="number" id="capo" min="0" max="12" value="0">

                <label for="capoAsWritten">Written with capo:</label>
                <input class="whole-number" type="number" id="capoAsWritten" min="0" max="12" value="0">

                <br>

                <label for="colorful-chords">Colorful chords:</label>
                <input type="checkbox" id="colorful-chords" value="true" checked>

                <label for="colorful-headers">Colorful headers:</label>
                <input type="checkbox" id="colorful-headers" value="true" checked>

                <label for="padding">Padding:</label>
                <input class="whole-number" type="number" id="padding" min="0" max="99" step="5" value="0">
            </div>

            <div class="keyboard-shortcuts">
                Keyboard shortcuts:
                <strong>h</strong> - hide/show controls,
                <strong>n</strong> - decrease font size,
                <strong>m</strong> - increase font size
            </div>
        </div>
    </div>

    <div class="container">
        <div id="left-edge-pixel-anchor"></div>
        <div id="content"></div>
        <div id="right-edge-pixel-anchor"></div>
    </div>

    <script id="utilityFunctions">
        function getHashParam(param) {
            if (!window.location.hash) {
                return null;
            }

            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            return hashParams.get(param);
        }

        function setHashParam(param, value) {
            const hashParams = new URLSearchParams(window.location.hash && window.location.hash.substring(1) || '');
            hashParams.set(param, value);
            window.location.hash = '#' + hashParams.toString();
        }

        function readCookie(name)  {
            const cookie = document.cookie;
            const cookies = cookie.split("; ");
            for (const cookie of cookies) {
                const [cookieName, cookieValue] = cookie.split('=');
                if (cookieName === name) {
                    return decodeURIComponent(cookieValue);
                }
            }

            return undefined;
        }

        function writeCookie(name, value, options = {}) {
            const {
                daysToExpire = null,
                path = '/',
                domain = '',
                secure = false,
                sameSite = 'Lax'
            } = options;

            let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

            if (daysToExpire !== null) {
                const expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() + daysToExpire);
                cookieString += `; expires=${expirationDate.toUTCString()}`;
            }

            cookieString += `; path=${path}`;

            if (domain) {
                cookieString += `; domain=${domain}`;
            }

            if (secure) {
                cookieString += '; secure';
            }

            cookieString += `; SameSite=${sameSite}`;

            document.cookie = cookieString;
        }

        function getValueFromCookieDb(cookieStorageName) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                if (cookieValue != undefined) {
                    const jsonCookieValue = JSON.parse(cookieValue);
                    return jsonCookieValue[keyName];
                }
            } catch {
                console.error(`Error reading value from cookie: ${cookieStorageName}`);
            }

            return undefined;
        }

        function setValueInCookieDb(cookieStorageName, value) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                const jsonCookieValue = cookieValue != undefined ? JSON.parse(cookieValue) : {};
                jsonCookieValue[keyName] = value;
                writeCookie(cookieName, JSON.stringify(jsonCookieValue));
            } catch {
                console.error(`Error writing value to cookie: ${cookieStorageName}`);
            }
        }

        function toString(value) {
            return value == undefined ? '' : `${value}`;
        }

        function floatToString(value, precision) {
            return value == undefined ? '' : value.toFixed(precision);
        }

        function roundFloat(value, precision) {
            const factor = Math.pow(10, precision);
            return Math.round((value + Number.EPSILON) * factor) / factor;
        }

        function toFloat(value) {
            const result = parseFloat(value);
            return isNaN(result) ? undefined : result;
        }

        function toBoolean(value) {
            return value === true || value === 'true';
        }

        function coalesce(value, defaultValue) {
            return value == undefined ? defaultValue : value;
        }

        function isDisplayed(element) {
            return element.style.display !== 'none';
        }

        function isEmpty(str) {
            return str == undefined || str === '';
        }

        function isWhitespace(str) {
            return str == undefined || str.trim() === '';
        }

        function matchFirst(regex, str) {
            if (str == undefined) {
                return undefined;
            }

            const matches = Array.from(str.matchAll(regex));
            if (matches.length == 0) {
                return undefined;
            }

            return matches[0];
        }

        function createElement(elementName, className, style) {
            const el = document.createElement(elementName);

            if (Array.isArray(className)) {
                el.className = className.join(" ");
            } else if (className) {
                el.className = className;
            }

            if (style) {
                for (const [key, value] of Object.entries(style)) {
                    el.style[key] = value;
                }
            }

            return el;
        }

        function elementSize(element) {
            const boundingRect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);

            function parsePixels(styleValue) {
                return styleValue ? parseFloat(styleValue) : 0;
            }

            return {
                width: boundingRect.width + parsePixels(style.marginLeft) + parsePixels(style.marginRight),
                height: boundingRect.height + parsePixels(style.marginTop) + parsePixels(style.marginBottom)
            }
        }

        function encodeHtml(str) {
            const el = createElement('div');
            el.textContent = str;
            return el.innerHTML;
        }

        function applyClass(element, condition, className) {
            if (condition) {
                element.classList.add(className);
            } else {
                element.classList.remove(className);
            }
        }

        function span(content, className) {
            if (isEmpty(content)) {
                return '';
            }

            return `<span class='${className}'>${encodeHtml(content)}</span>`;
        }

        function rgx(optionArg, ...args) {
            if (typeof optionArg === 'string' || optionArg instanceof String) {
                return createRegex({name: optionArg}, args);
            } else if (optionArg instanceof RegExp) {
                return createRegex({}, [optionArg, ...args]);
            } else if (typeof optionArg === 'object') {
                return createRegex(optionArg, args);
            } else {
                throw new Error("Unsupported type of option parameter");
            }

            function createRegex(options, regexes) {
                let regexStr = regexes.length === 1 ? processRegex(regexes[0]).source
                                                    : regexes.map(regex => `(${processRegex(regex).source})`)
                                                             .join('');

                if (options.name || options.optional || options.repeat) {
                    if (options.name) {
                        regexStr = `(?<${options.name}>${regexStr})`;
                    } else {
                        regexStr = `(${regexStr})`;
                    }

                    if (options.repeat) {
                        if (options.optional) {
                            regexStr += "*";
                        } else {
                            regexStr += "+";
                        }
                    } else if (options.optional) {
                        regexStr += "?";
                    }
                }

                return new RegExp(regexStr, options.flags);
            }

            function createDisjunction(regexArray) {
                return new RegExp(regexArray.map(regex => processRegex(regex).source).join('|'));
            }

            function processRegex(regex) {
                if (regex instanceof RegExp) {
                    return regex;
                } else if (Array.isArray(regex)) {
                    return createDisjunction(regex);
                } else {
                    throw new Error("Only regexes and arrays are supported");
                }
            }
        }

        function bindInputAndHash(element, hashParam, cookieStorageName, onChange, parse, stringify) {
            parse = parse || (value => value);
            stringify = stringify || (value => value);

            let currentValue = parse('');

            function loadFromUrl() {
                const value = getHashParam(hashParam);

                if (value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function loadFromCookie() {
                const value = getValueFromCookieDb(cookieStorageName)

                if (value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function loadFromElement() {
                const rawValue = element.nodeName === 'INPUT' && element.type === 'checkbox' ? (element.checked ? element.value : '') : element.value;
                const parsedValue = parse(rawValue);

                if (parsedValue !== currentValue) {
                    currentValue = parsedValue;
                    return true;
                }

                return false;
            }

            function updateUrl() {
                if (hashParam) {
                    const existingHashValue = getHashParam(hashParam);
                    const stringifiedCurrentValue = stringify(currentValue);

                    if (!existingHashValue || stringifiedCurrentValue !== existingHashValue) {
                        setHashParam(hashParam, stringifiedCurrentValue);
                    }
                }
            }

            function updateCookie() {
                if (cookieStorageName) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    setValueInCookieDb(cookieStorageName, stringifiedCurrentValue);
                }
            }

            function updateElement() {
                if (element) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    if (element.nodeName === 'INPUT' && element.type === 'checkbox') {
                        element.checked = element.value === stringifiedCurrentValue;
                    } else {
                        element.value = stringifiedCurrentValue;
                    }
                }
            }

            if (element) {
                element.addEventListener('input', () => {
                    if (loadFromElement()) {
                        updateUrl();
                        updateCookie();
                        onChange(currentValue);
                    }
                });
            }

            if (hashParam) {
                window.addEventListener('hashchange', () => {
                    if (loadFromUrl()) {
                        updateElement();
                        updateCookie();
                        onChange(currentValue);
                    }
                });
            }

            if (hashParam && getHashParam(hashParam) != undefined) {
                loadFromUrl();
                updateElement();
            } else if (cookieStorageName && getValueFromCookieDb(cookieStorageName) != undefined) {
                loadFromCookie();
                updateElement();
            } else if (element) {
                loadFromElement();
            }

            return {
                get: () => currentValue,
                set: function(value) {
                    currentValue = value;
                    updateElement();
                    updateUrl();
                    updateCookie();
                    onChange(currentValue);
                },
                setElementValueSilently: function(value) {
                    currentValue = value;
                    updateElement();
                },
                setSilentlyIfNotInUrl: function(value) {
                    if (!(hashParam && getHashParam(hashParam) != undefined)) {
                        currentValue = value;
                        updateElement();
                        return true;
                    }
                    return false;
                }
            }
        }
    </script>

    <script id="domainFunctions">
        const regexes = {
            chord: rgx({flags: "g"},
                       /^|(?<=[\s|()\-])/,
                       rgx({name: "prefix", optional: true}, /⁺|•/),
                       [/N\.C\./,
                        rgx(
                            rgx("root", /(C|F)(♯|#)?|(E|B|H)(b|♭)?|(D|G|A)(♯|#|b|♭)?/),
                            rgx({name: "variant", optional: true}, [
                                /(maj7|M7|7)?sus(2|4)?/,
                                /dim|aug|M|°|ø/,
                                rgx(/(m|min)?/,
                                    /(2|4|5|6|((maj|M)?(7|9|11|13)))?/,
                                    /((♯|#|b|♭)(5|9)|add(♯|#|b|♭)?(9|11|13))?/),
                            ]),
                            rgx({optional: true}, /\//, rgx("bass", /(C|F)(♯|#)?|(E|B|H)(b|♭)?|(D|G|A)(♯|#|b|♭)?/)))
                        ],
                        rgx({name: "suffix", optional: true}, /⁰|¹|²|³|⁴|⁵|⁶|⁷|⁸|⁹|ᐟ|ᐧ|⁺/),
                        /$|(?=[\s|()\-*,])/),

            header: /^(\s*)(\[)([^\]]+)(\])(\s*)$/g,
            fingering: /((\d|x){4,7})/g,
            allowedWithChords: /\([^()]+\)|[\s|%*()\-[\]]/g,
            capoMetadata: /^{capo(:|\s)?\s*(?<capo>\d+)(th|nd)?(\s[^}]*)?}\s*$/gi,
            tab: /^\s*((C|F)(♯|#)?|(E|B|H)(b|♭)?|(D|G|A)(♯|#|b|♭)?)\|[\-|()~\dhpx]+\|$/gi
        };

        const noteChart = (function() {
            const noteDegrees = {
                'C': 0,
                'D': 2,
                'E': 4,
                'F': 5,
                'G': 7,
                'A': 9,
                'H': 11,
                'B': 11,
            };

            const accidentals = {
                '♯' : 1,
                '#' : 1,
                'b' : -1,
                '♭' : -1,
            }

            const notes = {};
            for (accidental of Object.keys(accidentals)) {
                notes[accidental] = [];

                for (const [key, value] of Object.entries(noteDegrees)) {
                    notes[accidental][value] = key;
                }

                for (let i = 0; i < 12; i++) {
                    if (!notes[accidental][i]) {
                        notes[accidental][i] = notes[accidental][i - accidentals[accidental]] + accidental;
                    }
                }
            }

            return {noteDegrees, accidentals, notes};
        })();

        function isHeaderLine(line) {
            return !isWhitespace(line) && line.match(regexes.header);
        }

        function isTabLine(line) {
            return line.match(regexes.tab);
        }

        function isChordLine(line) {
            if (isWhitespace(line) || isTabLine(line)) {
                return false;
            }

            const allowedWithChords = rgx({repeat: true, optional: true}, [regexes.allowedWithChords, regexes.fingering]);
            const nothingButChordsRegex = rgx(/^/,
                                              allowedWithChords,
                                              rgx({optional: false, repeat: true},
                                                  regexes.chord,
                                                  allowedWithChords),
                                              /$/);
            return line.match(nothingButChordsRegex);
        }

        function isTextLine(line) {
            return !isChordLine(line) && !isHeaderLine(line) && !isWhitespace(line);
        }

        function processChord(chord, capoAsWritten, transpose, capo, preferredAccidental) {
            function processNote(note) {
                let degree = noteChart.noteDegrees[note[0]] + (noteChart.accidentals[note[1]] || 0);

                degree += coalesce(transpose, 0) - coalesce(capo, 0) + capoAsWritten;

                degree %= 12;
                if (degree < 0) {
                    degree += 12;
                }

                return noteChart.notes[coalesce(preferredAccidental, '♯')][degree]; // ♭ b ♯ #
            }

            if (!chord.root) {
                return (chord.prefix ?? "") +  "N.C." + (chord.suffix ?? "");
            }

            let result = processNote(chord.root);

            if (chord.variant) {
                result += chord.variant;
            }

            if (chord.bass) {
                result += "/" + processNote(chord.bass);
            }

            return (chord.prefix ?? "") + result + (chord.suffix ?? "");
        }

        function spanifyChords(line, capoAsWritten, transpose, capo, preferredAccidental) {
            const chordMatch = line.match(regexes.chord);
            if (!chordMatch || (chordMatch.length < 2 && !isChordLine(line))) {
                return encodeHtml(line);
            }

            const chordWithWhitespace = new RegExp(`${regexes.chord.source}(?<whitespace>\\s*)`, "g");

            return line.replaceAll(chordWithWhitespace, (match, ...args) => {
                const chord = args.at(-1);

                let whitespace = chord.whitespace || '';
                const originalChordLength = match.length - whitespace.length;

                const processedChord = processChord(chord, capoAsWritten, transpose, capo, preferredAccidental);

                if (processedChord.length < originalChordLength) {
                    whitespace = ' '.repeat(originalChordLength - processedChord.length) + whitespace;
                } else if (processedChord.length > originalChordLength && whitespace.length >= 2) {
                    whitespace = whitespace.substring(Math.min(processedChord.length - originalChordLength,
                                                               whitespace.length - 1));
                }

                return `${span(processedChord, 'chord')}${whitespace}`;
            });
        }

        function createLineHtmlElement(line, nextLine, capoAsWritten, transpose, capo, preferredAccidental) {
            if (isWhitespace(line)) {
                const element = createElement('div', ['line', 'empty-line']);
                element.innerHTML = "<br>"
                if (isHeaderLine(nextLine)) {
                    element.classList.add("pre-header-line");
                }
                return element;
            } else if (isHeaderLine(line)) {
                const element = createElement('div', ['line', 'header-line']);
                element.innerHTML = line.replaceAll(
                    regexes.header,
                    (match, wh1, br1, title, br2, wh2) =>
                        `<span>${span(wh1, 'wh')}${span(br1, 'bracket')}${span(title, 'title')}${span(br2, 'bracket')}${span(wh2, 'wh')}</span>`);
                return element;
            } else {
                const element = createElement('div', 'line');
                element.innerHTML = spanifyChords(line, capoAsWritten, transpose, capo, preferredAccidental);
                return element;
            }
        }

        function inferCapo(text) {
            const lines = text.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const capoMetadata = matchFirst(regexes.capoMetadata, lines[i]);
                if (capoMetadata) {
                    return coalesce(toFloat(capoMetadata.groups.capo), 0);
                }

                if (!isWhitespace(lines[i])) {
                    break;
                }
            }

            return 0;
        }

        function parseLines(text) {
            const lines = text.split('\n');
            const result = [];

            for (let i = 0; i < lines.length; i++) {
                if (isWhitespace(lines[i])) {
                    // if two empty lines precede header, keep only one
                    if (isWhitespace(lines[i + 1]) && isHeaderLine(lines[i + 2])) {
                        continue;
                    }

                    // remove up to two empty lines after a header
                    if (isHeaderLine(lines[i - 1]) ||
                        isWhitespace(lines[i - 1]) && isHeaderLine(lines[i - 2])) {
                        continue;
                    }
                }

                result.push(lines[i].trimEnd()); // Trim whitespace from the end of each line

                // enforce one empty line before a header
                if (!isWhitespace(lines[i]) && isHeaderLine(lines[i + 1])) {
                    result.push("");
                }
            };

            // Remove empty lines at the end of the text
            while (result.length > 0 && isWhitespace(result[result.length - 1])) {
                result.pop();
            }

            return result;
        }
    </script>

    <script id="main">
        const text = bindInputAndHash(document.getElementById('input-text'), 'text', null, updateContent);
        const fontSize = bindInputAndHash(document.getElementById('font-size'), 'fontSize', null, updateContent, toFloat, v => floatToString(v, 1));
        const transpose = bindInputAndHash(document.getElementById('transpose'), 'transpose', null, updateContent, toFloat, v => floatToString(v, 0));
        const capo = bindInputAndHash(document.getElementById('capo'), 'capo', null, updateContent, toFloat, v => floatToString(v, 0));
        const capoAsWritten = bindInputAndHash(document.getElementById('capoAsWritten'), 'capoAsWritten', null, updateContent, toFloat, v => floatToString(v, 0));
        const preferredAccidental = bindInputAndHash(document.getElementById('preferred-accidental'), 'preferredAccidental', 'db:preferredAccidental', updateContent);
        const colorfulChords = bindInputAndHash(document.getElementById('colorful-chords'), 'colorfulChords', 'db:colorfulChords', updateContent, toBoolean, toString);
        const colorfulHeaders = bindInputAndHash(document.getElementById('colorful-headers'), 'colorfulHeaders', 'db:colorfulHeaders', updateContent, toBoolean, toString);
        const padding = bindInputAndHash(document.getElementById('padding'), 'padding', 'db:padding', updateContent, toFloat, v => floatToString(v, 0));
        const title = bindInputAndHash(null, 'title', null, value => document.title = value);

        const contentDiv = document.getElementById('content');
        const controlsWrapper = document.getElementById('controls-wrapper');
        const containerDiv = document.querySelector('.container');

        // Initial title
        document.title = title.get() || 'Chord Projector';

        // Hide controls by default when text is passed via URL
        if (text.get()) {
            controlsWrapper.style.display = 'none';
            containerDiv.classList.add('fullscreen');
        }

        if (text.get() && getHashParam('fontSize') == undefined) {
            updateContentAndFitToScreen();
        }
        else {
            updateContent();
        }

        function updateContentAndFitToScreen() {
            const defaultSize = fontSize.get();

            const fontSizes = [];
            for (let size = 8, i = 0; size <= 20; size = roundFloat(size + 0.2, 2), i++) {
                fontSizes[i] = size;
            }

            let low = 0;
            let high = fontSizes.length - 1;
            let highestFit = 0;

            while (low <= high) {
                const i = Math.floor((low + high) / 2);
                fontSize.setElementValueSilently(fontSizes[i]);

                if (updateContent()) { // updateContent returns true if it fits
                    low = i + 1;
                    if (fontSizes[i] > highestFit) {
                        highestFit = fontSizes[i];
                    }
                } else {
                    high = i - 1;
                }
            }

            fontSize.setElementValueSilently(highestFit > 0 ? highestFit : defaultSize);
            updateContent();
        }

        function updateContent() {
            contentDiv.innerHTML = '';

            containerDiv.style.padding = padding.get() + 'px';

            applyClass(contentDiv, colorfulChords.get(), 'colorful-chords');
            applyClass(contentDiv, colorfulHeaders.get(), 'colorful-headers');

            if (fontSize.get()) {
                contentDiv.style.fontSize = fontSize.get() + 'px';
            }

            const inferredCapo = inferCapo(text.get());
            if (capoAsWritten.setSilentlyIfNotInUrl(inferredCapo)) {
                capo.setSilentlyIfNotInUrl(inferredCapo);
            }

            const availableHeight = contentDiv.clientHeight;
            const availableWidth = containerDiv.clientWidth;

            const lines = parseLines(text.get());
            const lineElements = lines.map((line, i) => createLineHtmlElement(line,
                                                                              lines[i+1],
                                                                              capoAsWritten.get(),
                                                                              transpose.get(),
                                                                              capo.get(),
                                                                              preferredAccidental.get()));

            const columns = [];
            let currentColumn = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const nextLine = lines[i + 1];

                const lineElement = lineElements[i];
                const nextLineElement = lineElements[i + 1];

                let lineFitsCurrentColumn = false;

                if (currentColumn) {
                    currentColumn.div.appendChild(lineElement);
                    let requiredHeight = elementSize(lineElement).height;

                    if (nextLine && isChordLine(line) && isTextLine(nextLine)) {
                        currentColumn.div.appendChild(nextLineElement);
                        requiredHeight += elementSize(nextLineElement).height;
                        currentColumn.div.removeChild(nextLineElement);
                    }

                    lineFitsCurrentColumn = currentColumn.height + requiredHeight <= availableHeight;

                    if (!lineFitsCurrentColumn) {

                        if (isWhitespace(line)) {
                            lineElement.classList.add('overflow-y-hidden');
                        } else {
                            currentColumn.div.removeChild(lineElement);
                        }
                    } else {
                        currentColumn.width = Math.max(currentColumn.width, elementSize(lineElement).width);
                        currentColumn.height += elementSize(lineElement).height;
                    }
                }

                if (!lineFitsCurrentColumn) {
                    if (isWhitespace(line)) {
                        continue;
                    }

                    const newColumnDiv = createElement('div', 'column', {position: 'absolute', visibility: 'hidden'});
                    contentDiv.appendChild(newColumnDiv);
                    newColumnDiv.appendChild(lineElement);

                    currentColumn = {
                        div: newColumnDiv,
                        width: elementSize(lineElement).width,
                        height: elementSize(lineElement).height
                    };

                    columns.push(currentColumn);
                }
            }

            // Render columns with their content
            columns.forEach((column, i) => {
                column.div.style.width = column.width + 'px';
                column.div.style.position = '';
                column.div.style.visibility = '';
            });

            return elementSize(contentDiv).width <= availableWidth;
        }
    </script>

    <script id="setupEventListeners">
        window.addEventListener('resize', updateContent);

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            const anyInputHasFocus = Array.from(document.querySelectorAll('input, textarea'))
                                          .some(item => document.activeElement === item)

            if (anyInputHasFocus) {
                return;
            }

            if (e.key.toLowerCase() === 'h') { // Toggle controls visibility with 'h'
                if (isDisplayed(controlsWrapper)) {
                    controlsWrapper.style.display = 'none';
                    containerDiv.classList.add('fullscreen');
                } else {
                    controlsWrapper.style.display = 'flex';
                    containerDiv.classList.remove('fullscreen');
                }

                updateContent();
            } else if (e.key.toLowerCase() === 'n') { // Decrease font size with 'n'
                const currentSize = fontSize.get();
                if (currentSize > 8) { // Minimum font size
                    fontSize.set(roundFloat(currentSize - 0.2, 2));
                }
            } else if (e.key.toLowerCase() === 'm') { // Increase font size with 'm'
                const currentSize = fontSize.get();
                if (currentSize < 36) { // Maximum font size
                    fontSize.set(roundFloat(currentSize + 0.2, 2));
                }
            }
        });

        if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window &&
            "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
            const leftObserver = new IntersectionObserver(
                entries => applyClass(contentDiv, !entries[0].isIntersecting, 'has-horizontal-overflow-left'));

            const rightObserver = new IntersectionObserver(
                entries => applyClass(contentDiv, !entries[0].isIntersecting, 'has-horizontal-overflow-right'));

            leftObserver.observe(document.querySelector("#left-edge-pixel-anchor"));
            rightObserver.observe(document.querySelector("#right-edge-pixel-anchor"));
        }
    </script>
</body>
</html>