<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Projector</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Music&family=Roboto+Mono:wght@100..700&display=block" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Julia Mono Webfont';
            font-style: normal;
            font-weight: 400;
            font-display: block;
            src: url(fonts/JuliaMono-Regular.woff2) format('woff2');
        }

        @font-face {
            font-family: 'Julia Mono Webfont';
            font-style: normal;
            font-weight: 700;
            font-display: block;
            src: url(fonts/JuliaMono-SemiBold.woff2) format('woff2');
        }

        @font-face {
            font-family: 'Adobe NotDef';
            font-display: block;
            src: url('fonts/AdobeNotDef-Regular.woff2') format('woff2');
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Roboto Mono', 'Julia Mono Webfont', 'Courier New', monospace;
            overflow: hidden; /* Prevents scrolling on the body */
        }

        body {
            display: flex;
            flex-direction: column;
            padding: 5px;
            font-size: 15px; /* Default size that will be configurable */
            box-sizing: border-box;
        }

        .controls-wrapper {
            display: flex;
            gap: 10px;
            padding-bottom: 10px;
            box-sizing: border-box;
            border-bottom: 1px solid #ddd;
        }

        .controls-container {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .fullscreen .controls-wrapper {
            display: none;
        }

        .text-input-container {
            flex: 7;
        }

        .controls-container {
            flex: 4;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .controls {
            margin-bottom: 5px;
            font-size: 12px;
        }

        .controls label {
            display: inline-block;
            margin-top: 7px;
            margin-right: 2px;
        }

        .controls input {
            width: 50px;
        }

        .controls input[type="checkbox"] {
            width: 13px;
            margin-top: 8px;
        }

        .controls input, .controls select {
            margin: 3px;
        }

        .controls button {
            width: 100px;
            margin: 3px;
        }

        .keyboard-shortcuts {
            margin-top: auto;
            font-size: 12px;
            color: #666;
        }

        textarea {
            width: 100%;
            height: 100%;
            resize: none;
            box-sizing: border-box;
            font-family: inherit;
            font-size: inherit;
        }

        .overflow-y-hidden {
            overflow-y: hidden;
        }

        .content-wrapper {
            display: flex;
            flex: 1;
            position: relative;
        }

        .content-container {
            display: flex;
            width: 100%;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden; /* No vertical scrolling */
        }

        #content {
            display: flex;
            flex-shrink: 0;
        }

        .column {
            flex-shrink: 0;
            position: relative;
            margin-right: 20px;
            padding-right: 10px;
        }

        .has-horizontal-overflow-left::before,
        .has-horizontal-overflow-right::after {
            content: '';
            position: absolute;
            top: -1px;
            bottom: -5px;
            width: 1010px;
            pointer-events: none;
            z-index: 1;
        }

        .has-horizontal-overflow-left::before {
            left: -1000px;
            background: linear-gradient(to left, transparent, rgba(255,0,0,0.1) 0px, rgba(255,0,0,0.65) 15px, rgba(255,0,0,0.65) 100%);
        }

        .has-horizontal-overflow-right::after {
            right: -1000px;
            background: linear-gradient(.25turn, transparent, rgba(255,0,0,0.1) 0px, rgba(255,0,0,0.65) 15px, rgba(255,0,0,0.65) 100%);
        }

        .fullscreen .has-horizontal-overflow-left::before,
        .fullscreen .has-horizontal-overflow-right::after {
            top: -5px !important;
        }

        /* column separator */
        .column:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 1px;
            background-color: #ccc;
            z-index: 0;
        }

        .column:last-child {
            margin-right: 0;
            padding-right: 0;
        }

        .line {
            line-height: 1.3; /* Tighter line spacing */
            margin: 0;
            padding: 0;
            white-space: pre; /* Preserves whitespace including multiple spaces */
            text-overflow: clip; /* Clips text that doesn't fit */
        }

        .line .chord {
            font-weight: 700;
            background-color: rgb(232, 232, 232);
            border-radius: 3px;
            margin-left: -.13em;
            padding-left: .13em;
            margin-right: -.13em;
            padding-right: .13em;
        }

        .line .chord-prefix,
        .line .chord-suffix {
            /* to make visible above the chord span when it overlaps */
            position: relative;
            z-index: 1;
        }

        .colorful-chords .line .chord {
            color: rgb(0, 123, 255);
            background-color: rgb(240, 248, 255);
        }

        .line.empty-line {
            line-height: 1;
        }

        .line.empty-line.pre-highlighted-line + .line.highlighted-line {
            margin-top: -0.3em;
        }

        .line.highlighted-line + .line.empty-line.pre-highlighted-line {
            margin-top: -0.5em;
        }

        .line.highlighted-line {
            padding-bottom: 0.4em;
        }

        .line.highlighted-line > span {
            background-color: rgb(232, 232, 232);
            border-radius: 5px;
        }

        .line.highlighted-line .wh {
            display:none;
        }

        .line .inline-metadata {
            background-color: rgb(232, 232, 232);
            border-radius: 5px;
        }

        .colorful-headers .line .inline-metadata .brace {
            color: rgb(210, 250, 210);
        }

        .colorful-headers .line .inline-metadata {
            margin-left: 0.2em;
            margin-right: 0.2em;
            background-color: rgb(210, 250, 210);
        }

        .colorful-headers .line .inline-metadata .brace:first-child {
            margin-right: -0.2em;
        }

        .colorful-headers .line .inline-metadata .brace:last-child {
            margin-left: -0.2em;
        }
        .colorful-headers .line.header-line .title {
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 0.98em;
            letter-spacing: 1px;
        }

        .colorful-headers .line.metadata-line .metadata {
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 0.98em;
            font-style: italic;
        }

        .colorful-headers .line.header-line > span {
            background-color: rgb(238, 229, 242);
        }

        .colorful-headers .line.header-line .bracket {
            font-size: 0.6em;
            color: rgb(232, 232, 232);
        }

        .colorful-headers .line.metadata-line > span {
            background-color: rgb(210, 250, 210);
        }

        .colorful-headers .line.metadata-line .brace {
            font-size: 0.6em;
            color: rgb(210, 250, 210);
        }

        #leftEdgePixelAnchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }

        #rightEdgePixelAnchor {
            flex-shrink: 0;
            width: 1px;
            height: 1px;
            user-select: none;
        }

        /* utilities */

        .flex-row {
            display: flex;
            flex-direction: row;
        }

        .flex-column {
            display: flex;
            flex-direction: column;
        }

        .align-flex-end {
            align-items: flex-end;
        }

        .flex1 { flex: 1; }
        .flex2 { flex: 2; }
        .flex3 { flex: 3; }
        .flex4 { flex: 4; }
        .flex5 { flex: 5; }
        .flex6 { flex: 6; }
        .flex7 { flex: 7; }
        .flex8 { flex: 8; }
        .flex9 { flex: 9; }
        .flex10 { flex: 10; }
        .flex11 { flex: 11; }
        .flex12 { flex: 12; }
        .flex13 { flex: 13; }

        /* specific character styling */

        .line .char[content="|"] {
            display: inline-block;
            transform: translateY(-1px) scaleY(1.2);
            font-weight: 700;
        }

        .line .char[content="ùÑê"] {
            display: inline-block;
            width: 1ch;
            text-align: center;
            vertical-align: middle;
            font-weight: 700;
            font-family: 'Noto Music';
        }
    </style>
</head>
<body>
    <div id="controlsWrapper" class="controls-wrapper">
        <div class="text-input-container">
            <textarea id="text" placeholder="Enter your text here..."></textarea>
        </div>

        <div class="controls-container">
            <div class="controls flex-row">
                <div class="flex-column flex6 align-flex-end">
                    <div class="flex-row">
                        <label for="fontSize">Font size:</label>
                        <input type="number" id="fontSize" min="8" max="24" value="15" step="0.1">
                    </div>

                    <div class="flex-row">
                        <label for="transpose">Transpose:</label>
                        <input type="number" id="transpose" min="-12" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="colorfulChords">Colorful chords:</label>
                        <input type="checkbox" id="colorfulChords" value="true" checked>
                    </div>
                </div>

                <div class="flex-column flex6 align-flex-end">
                    <div class="flex-row">
                        <label for="padding">Padding:</label>
                        <input type="number" id="padding" min="0" max="99" step="5" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="capo">Capo:</label>
                        <input type="number" id="capo" min="0" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <label for="colorfulHeaders">Colorful headers:</label>
                        <input type="checkbox" id="colorfulHeaders" value="true" checked>
                    </div>
                </div>

                <div class="flex-column flex10 align-flex-end">
                    <div class="flex-row">
                        <label for="preferredAccidental">Preferred accidental:</label>
                        <select id="preferredAccidental">
                            <option value="#" selected>#</option>
                            <option value="‚ôØ">‚ôØ (stylized)</option>
                            <option value="b">b</option>
                            <option value="‚ô≠">‚ô≠ (stylized)</option>
                        </select>
                    </div>

                    <div class="flex-row">
                        <label for="capoAsWritten">Written with capo:</label>
                        <input type="number" id="capoAsWritten" min="0" max="12" value="0">
                    </div>

                    <div class="flex-row">
                        <button id="hideAndFitButton" type="button">Hide & Fit</button>
                        <button id="hideButton" type="button">Hide</button>
                    </div>
                </div>
            </div>

            <div class="keyboard-shortcuts">
                Keyboard shortcuts:
                <strong>h</strong> - toggle controls,
                <strong>n</strong> - decrease font,
                <strong>m</strong> - increase font,
                <strong>f</strong> - fit text
            </div>
        </div>
    </div>

    <div id="contentWrapper" class="content-wrapper">
        <div id="contentContainer" class="content-container">
            <div id="leftEdgePixelAnchor"></div>
            <div id="content"></div>
            <div id="rightEdgePixelAnchor"></div>
        </div>
    </div>

    <script id="utilityFunctions">
        function getHashParam(param) {
            if (!window.location.hash) {
                return null;
            }

            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            return hashParams.get(param);
        }

        function setHashParam(param, value) {
            const hashParams = new URLSearchParams(window.location.hash && window.location.hash.substring(1) || '');
            if (value == undefined) {
                hashParams.delete(param);
            } else {
                hashParams.set(param, value);
            }
            window.location.hash = '#' + hashParams.toString();
        }

        function readCookie(name)  {
            const cookie = document.cookie;
            const cookies = cookie.split("; ");
            for (const cookie of cookies) {
                const [cookieName, cookieValue] = cookie.split('=');
                if (cookieName === name) {
                    return decodeURIComponent(cookieValue);
                }
            }

            return undefined;
        }

        function writeCookie(name, value, options = {}) {
            const {
                daysToExpire = null,
                path = '/',
                domain = '',
                secure = false,
                sameSite = 'Lax'
            } = options;

            let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

            if (daysToExpire !== null) {
                const expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() + daysToExpire);
                cookieString += `; expires=${expirationDate.toUTCString()}`;
            }

            cookieString += `; path=${path}`;

            if (domain) {
                cookieString += `; domain=${domain}`;
            }

            if (secure) {
                cookieString += '; secure';
            }

            cookieString += `; SameSite=${sameSite}`;

            document.cookie = cookieString;
        }

        function getValueFromCookieDb(cookieStorageName) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                if (cookieValue != undefined) {
                    const jsonCookieValue = JSON.parse(cookieValue);
                    return jsonCookieValue[keyName];
                }
            } catch {
                console.error(`Error reading value from cookie: ${cookieStorageName}`);
            }

            return undefined;
        }

        function setValueInCookieDb(cookieStorageName, value) {
            try {
                const [cookieName, keyName] = cookieStorageName.split(":");
                const cookieValue = readCookie(cookieName);
                const jsonCookieValue = cookieValue != undefined ? JSON.parse(cookieValue) : {};
                jsonCookieValue[keyName] = value;
                writeCookie(cookieName, JSON.stringify(jsonCookieValue));
            } catch {
                console.error(`Error writing value to cookie: ${cookieStorageName}`);
            }
        }

        function compare(x, y) {
            return x < y ? -1 :
                   x > y ? 1 :
                   0;
        }

        function toString(value) {
            return value == undefined ? '' : `${value}`;
        }

        function floatToString(value, precision) {
            return value == undefined ? '' : value.toFixed(precision);
        }

        function toFloat(value) {
            const result = parseFloat(value);
            return isNaN(result) ? undefined : result;
        }

        function roundFloat(value, precision) {
            return Number(Math.round(value + 'e' + precision) + 'e-' + precision);
        }

        function toBoolean(value) {
            return value === true || value === 'true';
        }

        function isEmpty(str) {
            return str == undefined || str === '';
        }

        function isWhitespace(str) {
            return str == undefined || str.trim() === '';
        }

        function createElement(elementName, className, style) {
            const el = document.createElement(elementName);

            if (Array.isArray(className)) {
                el.className = className.filter(v => !!v).join(" ");
            } else if (className) {
                el.className = className;
            }

            if (style) {
                for (const [key, value] of Object.entries(style)) {
                    el.style[key] = value;
                }
            }

            return el;
        }

        function elementSize(element, options = {}) {
            function parsePixels(styleValue) {
                return styleValue ? parseFloat(styleValue) : 0;
            }

            const { includeMargin = true, includePadding = true } = options;

            const boundingRect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);

            return {
                width: boundingRect.width +
                       (includeMargin ? parsePixels(style.marginLeft) + parsePixels(style.marginRight) : 0) +
                       (includePadding ? 0 : -parsePixels(style.paddingLeft) - parsePixels(style.paddingRight)),

                height: boundingRect.height +
                        (includeMargin ? parsePixels(style.marginTop) + parsePixels(style.marginBottom) : 0) +
                        (includePadding ? 0 : -parsePixels(style.paddingTop) - parsePixels(style.paddingBottom)),
            }
        }

        function encodeHtml(str) {
            if (!str) {
                return '';
            };

            const el = createElement('div');
            el.textContent = str;
            return el.innerHTML;
        }

        function encodeAttr(str) {
            if (!str) {
                return '';
            };

            const el = createElement('div');
            el.setAttribute('attr', str);

            // Find out whether the browser used single or double quotes before encodedText
            const quote = el.outerHTML[el.outerHTML.search(/['"]/)];
            // Split up the generated HTML using the quote character; take item 1
            return el.outerHTML.split(new RegExp(quote))[1];
        }

        function applyClass(element, condition, className) {
            if (condition) {
                element.classList.add(className);
            } else {
                element.classList.remove(className);
            }
        }

        function span(content, className) {
            if (isEmpty(content)) {
                return '';
            }

            if (Array.isArray(className)) {
                className = className.filter(v => !!v).join(" ");
            }

            return `<span class='${className}'>${encodeHtml(content)}</span>`;
        }

        function rgx(optionArg, ...args) {
            if (typeof optionArg === 'string' || optionArg instanceof String) {
                return createRegex({name: optionArg}, args);
            } else if (optionArg instanceof RegExp || Array.isArray(optionArg)) {
                return createRegex({}, [optionArg, ...args]);
            } else if (typeof optionArg === 'object') {
                return createRegex(optionArg, args);
            } else {
                throw new Error("Unsupported type of option parameter");
            }

            function createRegex(options, regexes) {
                let regexStr = regexes.length === 1 ? processRegex(regexes[0]).source
                                                    : regexes.map(regex => `(${processRegex(regex).source})`)
                                                             .join('');
                regexStr = nameAndQuantify(options, regexStr);
                return new RegExp(regexStr, options.flags);
            }

            function createDisjunction(regexArray) {
                return new RegExp(regexArray.map(regex => processRegex(regex).source).join('|'));
            }

            function processRegex(regex) {
                if (regex instanceof RegExp) {
                    return regex;
                } else if (Array.isArray(regex)) {
                    return createDisjunction(regex);
                } else {
                    throw new Error("Only regexes and arrays are supported");
                }
            }

            function nameAndQuantify(options, regexStr) {
                const quantifier = options.repeat ? (options.optional ? '*' : '+')
                                                  : (options.optional ? '?' : '');

                if (options.name && options.repeat) {
                    // we need to put the repeat quantifier inside the named capture group
                    return `(?<${options.name}>(${regexStr})${quantifier})`
                }

                return options.name ? `(?<${options.name}>${regexStr})${quantifier}`
                                    : `(${regexStr})${quantifier}`;
            }
        }

        function matchAll(str, regex) {
            if (str == undefined) {
                return [];
            }

            regex = new RegExp(regex.source, regex.flags.includes("g") ? regex.flags : regex.flags + "g");
            return Array.from(str.matchAll(regex));
        }

        function matchFirst(str, regex) {
            const matches = matchAll(str, regex);
            if (matches.length == 0) {
                return undefined;
            }

            return matches[0];
        }

        function replaceAll(str, regex, replacer, unmatchedProcessor = (v => v)) {
            const matches = matchAll(str, regex);

            const result = [];
            let lastStrIndexInResult = -1;

            for (const match of matches) {
                const matchedSubstring = str.substring(match.index, match.index + match[0].length);
                const replacement = replacer(matchedSubstring, match.groups, match.index);

                if (match.index > lastStrIndexInResult + 1) {
                    result.push(unmatchedProcessor(str.substring(lastStrIndexInResult + 1, match.index),
                                                   lastStrIndexInResult + 1));
                }

                result.push(replacement);
                lastStrIndexInResult = match.index + matchedSubstring.length - 1;
            }

            if (str.length > lastStrIndexInResult + 1) {
                result.push(unmatchedProcessor(str.substring(lastStrIndexInResult + 1),
                                               lastStrIndexInResult + 1));
            }

            return result.join('');
        }

        function bindData(bindings, onChange, parse, stringify) {
            let { el, hash, cookie } = bindings;

            const identifier = el && (el.name || el.id);
            if (hash === true && identifier) {
                hash = identifier;
            }
            if (cookie === true && identifier) {
                cookie = "db:" + identifier;
            }

            let typeSpecificMethods = {};

            if (el && el.nodeName == 'INPUT' && el.type == 'checkbox') {
                parse = parse ?? toBoolean;
                stringify = stringify ?? toString;
            } else if (el && el.nodeName == 'INPUT' && el.type == 'number') {
                const stepAttr = el.step || '1';
                const [whole, decimal] = stepAttr.split('.');
                const precision = decimal ? decimal.length : 0;

                parse = parse ?? toFloat;
                stringify = stringify ?? (v => floatToString(v, precision));

                typeSpecificMethods = {
                    min: toFloat(el.min),
                    max: toFloat(el.max),
                    step: toFloat(stepAttr),
                    precision: precision,

                    increase: function() {
                        const newValue = roundFloat(this.get() + this.step, this.precision);
                        if (this.max == undefined || newValue <= this.max) {
                            this.set(newValue)
                        }
                    },

                    decrease: function() {
                        const newValue = roundFloat(this.get() - this.step, this.precision);
                        if (this.min == undefined || newValue >= this.min) {
                            this.set(newValue)
                        }
                    }
                }
            } else {
                parse = parse ?? (value => value);
                stringify = stringify ?? (value => value)
            }

            let currentValue = parse('');

            function loadFromUrl() {
                const value = getHashParam(hash);

                if (value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function loadFromCookie() {
                const value = getValueFromCookieDb(cookie)

                if (value != undefined) {
                    const parsedValue = parse(value);
                    if (parsedValue !== currentValue) {
                        currentValue = parsedValue;
                        return true;
                    }
                }

                return false;
            }

            function loadFromElement() {
                const rawValue = el.nodeName === 'INPUT' && el.type === 'checkbox' ? (el.checked ? el.value : '')
                                                                                   : el.value;
                const parsedValue = parse(rawValue);

                if (parsedValue !== currentValue) {
                    currentValue = parsedValue;
                    return true;
                }

                return false;
            }

            function updateUrl() {
                if (hash) {
                    const existingHashValue = getHashParam(hash);
                    const stringifiedCurrentValue = stringify(currentValue);

                    if (!existingHashValue || stringifiedCurrentValue !== existingHashValue) {
                        setHashParam(hash, stringifiedCurrentValue);
                    }
                }
            }

            function updateCookie() {
                if (cookie) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    setValueInCookieDb(cookie, stringifiedCurrentValue);
                }
            }

            function updateElement() {
                if (el) {
                    const stringifiedCurrentValue = stringify(currentValue);
                    if (el.nodeName === 'INPUT' && el.type === 'checkbox') {
                        el.checked = el.value === stringifiedCurrentValue;
                    } else {
                        el.value = stringifiedCurrentValue;
                    }
                }
            }

            if (el) {
                el.addEventListener('input', () => {
                    const previousValue = currentValue;
                    if (loadFromElement()) {
                        updateUrl();
                        updateCookie();
                        onChange(currentValue, previousValue);
                    }
                });
            }

            if (hash) {
                window.addEventListener('hashchange', () => {
                    const previousValue = currentValue;
                    if (loadFromUrl()) {
                        updateElement();
                        updateCookie();
                        onChange(currentValue, previousValue);
                    }
                });
            }

            if (hash && getHashParam(hash) != undefined) {
                loadFromUrl();
                updateElement();
            } else if (cookie && getValueFromCookieDb(cookie) != undefined) {
                loadFromCookie();
                updateElement();
            } else if (el) {
                loadFromElement();
            }

            return {
                get: () => currentValue,

                set: (value, additionalData) => {
                    const previousValue = currentValue;
                    currentValue = value;
                    updateElement();
                    updateUrl();
                    updateCookie();
                    onChange(currentValue, previousValue, additionalData);
                },

                setElementValueSilently: value => {
                    currentValue = value;
                    updateElement();
                },

                hasHashParam: () => hash && getHashParam(hash) != undefined,

                clearHashParam: () => {
                    if (hash) {
                        setHashParam(hash, undefined);
                    }
                },

                ...typeSpecificMethods
            }
        }

        function getEffectiveTextAreaSelection(element) {
            return element.selectionDirection == 'backward' ?
                {start: element.selectionEnd, end: element.selectionStart} :
                {start: element.selectionStart, end: element.selectionEnd};
        }

        function setTextAreaSelection(element, start, end) {
            const currentSelection = getEffectiveTextAreaSelection(element);
            start = start ?? currentSelection.start;
            end = end ?? currentSelection.end;

            element.selectionStart = Math.min(start, end);
            element.selectionEnd = Math.max(start, end);
            element.selectionDirection = start < end ? 'forward' :
                                         start > end ? 'backward' :
                                         'none';
        }

        function getStartOfLinePositionForTextAreaCaret(element) {
            const selectionEnd = getEffectiveTextAreaSelection(element).end;
            const previousLineEnd = element.value.lastIndexOf("\n", selectionEnd - 1);
            return previousLineEnd >= 0 ? previousLineEnd + 1 : 0;
        }

        function getEndOfLinePositionForTextAreaCaret(element) {
            const selectionEnd = getEffectiveTextAreaSelection(element).end;
            const lineEnd = element.value.indexOf("\n", selectionEnd);
            return lineEnd >= 0 ? lineEnd : element.value.length;
        }

        function findFloorUsingStepBinarySearch(low, high, step, precision, computeFunc, comparisonFunc) {
            let result = undefined;

            while (low <= high) {
                const mid = roundFloat(low + Math.floor((high - low) / 2 / step) * step, precision);
                const value = computeFunc(mid);
                const comparisonResult = comparisonFunc(value);

                if (comparisonResult <= 0) {
                    result = value;
                    low = roundFloat(mid + step, precision);
                } else {
                    high = roundFloat(mid - step, precision);
                }
            }

            return result;
        }
    </script>

    <script id="domainFunctions">
        const regexes = {
            chord: rgx(/^|(?<=[\s|()\-}])/,
                       rgx({name: "prefix", optional: true}, /\+|‚Å∫|‚Ä¢|\^|‚åÑ|‚§∫|·ëâ|~/),
                       rgx({name: "chord"},
                           [/N\.C\./,
                            /%/,
                            /X/,
                            rgx(rgx("root", /(C|F)(‚ôØ|#)?|(E|B|H)(b|‚ô≠)?|(D|G|A)(‚ôØ|#|b|‚ô≠)?/),
                                rgx({name: "variant", optional: true},
                                    [/(maj7|M7|7)?sus(2|4)?/,
                                     /dim|aug|M|¬∞|√∏/,
                                     rgx(/(m|min)?/,
                                         /(2|4|5|6|((maj|M)?(7|9|11|13)))?/,
                                         /((‚ôØ|#|b|‚ô≠)(5|9)|add(‚ôØ|#|b|‚ô≠)?(9|11|13))?/)
                                    ]),
                                rgx({optional: true}, /\//, rgx("bass", /(C|F)(‚ôØ|#)?|(E|B|H)(b|‚ô≠)?|(D|G|A)(‚ôØ|#|b|‚ô≠)?/)))
                           ]),
                        rgx({name: "suffix", optional: true, repeat: true}, /‚Å∞|¬π|¬≤|¬≥|‚Å¥|‚Åµ|‚Å∂|‚Å∑|‚Å∏|‚Åπ|·êü|·êß|‚Å∫|‚Ä¢|‚ñÆ|‚ñØ|‚ãà|‚ßì|\.|‚Ä¶|‚Ä•|‚Ä§|‚ô™|‚ô©|ùÑê|‚èú|‚èù|‚ó†|‚ó°|‚óá|‚¨¶|‚ô¢|‚óÜ|‚ô¶|‚ë†|‚ë°|‚ë£|‚ëß|‚ëØ|‚ù∂|‚ù∑|‚ùπ|‚ùΩ|‚ì∞/),
                        /$|(?=[\s|:()\-*,{])/),

            allowedWithChords: /\([^()]+\)|{[^{}]+}|[\s|%:*()\-[\]]/,
            fingering: /((\d|x){4,7})/,
            tablature: /^\s*((C|F)(‚ôØ|#)?|(E|B|H)(b|‚ô≠)?|(D|G|A)(‚ôØ|#|b|‚ô≠)?)\|[\-|()~\dhpx]+\|$/i,
            tablatureTiming: /^\s*(‚ßñ|‚è≤|ùÑû)\|[\-|()\d‚óá‚Ä§‚ô©.‚Ä¶‚ô™‚Ä•‚åáêíá‚ñ¨‚¨ì‚¨í‚åí‚èë‚èú‚èù‚ó†‚ó°‚¨≠‚¨¨\s]+\|$/i,
            metadata: /^(?<preWhitespace>\s)*(?<opener>{)(?<content>[^}]+)(?<closer>})(?<postWhitespace>\s*)$/,
            header: /^(?<preWhitespace>\s*)(?<opener>\[)(?<content>[^\]]+)(?<closer>\])(?<postWhitespace>\s*)$/,
            capoMetadata: /^{capo(:|\s)?\s*(?<capo>\d+)(th|nd)?(\s[^}]*)?}\s*$/i
        };

        const noteChart = (function() {
            const notes = {
                '#': ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                '‚ôØ': ['C', 'C‚ôØ', 'D', 'D‚ôØ', 'E', 'F', 'F‚ôØ', 'G', 'G‚ôØ', 'A', 'A‚ôØ', 'B'],
                'b': ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'],
                '‚ô≠': ['C', 'D‚ô≠', 'D', 'E‚ô≠', 'E', 'F', 'G‚ô≠', 'G', 'A‚ô≠', 'A', 'B‚ô≠', 'B']
            };

            const noteDegrees = {'H': 11};
            for (const noteValues of Object.values(notes)) {
                noteValues.forEach((note, i) => noteDegrees[note] = i);
            }

            return {notes, noteDegrees};
        })();

        function isHeaderLine(line) {
            return !isWhitespace(line) && regexes.header.test(line);
        }

        function isMetadataLine(line) {
            return !isWhitespace(line) && regexes.metadata.test(line);
        }

        function isHighlightedLine(line) {
            return isHeaderLine(line) || isMetadataLine(line);
        }

        function isTablatureLine(line) {
            return !isWhitespace(line) && (regexes.tablature.test(line) || regexes.tablatureTiming.test(line));
        }

        function isChordLine(line) {
            if (isWhitespace(line) || isTablatureLine(line)) {
                return false;
            }

            const allowedWithChords = rgx({repeat: true, optional: true}, [regexes.allowedWithChords, regexes.fingering]);
            const nothingButChordsRegex = rgx(/^/,
                                              allowedWithChords,
                                              rgx({repeat: true}, regexes.chord, allowedWithChords),
                                              /$/);
            return nothingButChordsRegex.test(line);
        }

        function isTextLine(line) {
            return !isWhitespace(line) && !isChordLine(line) && !isHighlightedLine(line) && !isTablatureLine(line);
        }

        function processChord(chord, capoAsWritten, transpose, capo, preferredAccidental) {
            function processNote(note) {
                let degree = noteChart.noteDegrees[note];

                degree += (transpose ?? 0) - (capo ?? 0) + capoAsWritten;
                degree %= 12;
                if (degree < 0) {
                    degree += 12;
                }

                return noteChart.notes[preferredAccidental ?? '‚ôØ'][degree];
            }

            if (!chord.root) {
                return chord.chord;
            }

            let result = processNote(chord.root);

            if (chord.variant) {
                result += chord.variant;
            }

            if (chord.bass) {
                result += "/" + processNote(chord.bass);
            }

            return result;
        }

        function charSpans(content) {
            if (!content) {
                return '';
            }

            return Array.from(content)
                        .map(c => `<span class="char" content="${encodeAttr(c)}">${encodeHtml(c)}</span>`)
                        .join('')
        }

        function spanifyChords(line, capoAsWritten, transpose, capo, preferredAccidental) {
            const chordMatches = matchAll(line, regexes.chord);
            if (chordMatches.length == 0 || (chordMatches.length < 2 && !isChordLine(line))) {
                return encodeHtml(line);
            }

            const chordOrMetadataRegex = rgx([/{(?<metadata>[^{}]+)}/,
                                              rgx(regexes.chord, /(?<whitespace>\s*)/)]);

            return replaceAll(line, chordOrMetadataRegex, (match, captureGroups, offset) => {
                if (captureGroups.metadata) {
                    return `<span class="inline-metadata">${span('{', 'brace') +
                                                            span(captureGroups.metadata, 'content') +
                                                            span('}', 'brace')}</span>`;
                }

                const chord = processChord(captureGroups, capoAsWritten, transpose, capo, preferredAccidental);

                let whitespace = captureGroups.whitespace ?? '';
                const lengthDiff = chord.length - captureGroups.chord.length;

                if (lengthDiff < 0) {
                    whitespace += ' '.repeat(-lengthDiff);
                } else if (lengthDiff > 0 && whitespace.length >= 1) {
                    // if followed by a bar that's not the last character in the line
                    const nextCharIndex = offset + match.length;
                    const canRemoveAllWhitespace = line[nextCharIndex] == '|' &&
                                                   nextCharIndex < line.length - 1;

                    whitespace = whitespace.substring(canRemoveAllWhitespace
                                                        ? lengthDiff
                                                        : Math.min(lengthDiff, whitespace.length - 1));
                }

                return '<span class="chord-container">' +
                       (captureGroups.prefix
                            ? `<span class="chord-prefix">${charSpans(captureGroups.prefix)}</span>`
                            : '') +
                       span(chord, 'chord') +
                       (captureGroups.suffix
                            ? `<span class="chord-suffix">${charSpans(captureGroups.suffix)}</span>`
                            : '') +
                       '</span>' +
                       whitespace;
            }, encodeHtml).replaceAll('|', charSpans);
        }

        function createLineHtmlElement(line, nextLine, capoAsWritten, transpose, capo, preferredAccidental) {
            if (isWhitespace(line)) {
                const element = createElement('div', ['line', 'empty-line', isHighlightedLine(nextLine) && 'pre-highlighted-line']);
                element.innerHTML = "<br>"
                return element;
            } else if (isHeaderLine(line)) {
                const element = createElement('div', ['line', 'header-line', 'highlighted-line']);
                element.innerHTML = replaceAll(line, regexes.header, (match, groups) =>
                    `<span>${span(groups.preWhitespace, 'wh') +
                             span(groups.opener, 'bracket') +
                             span(groups.content, 'title') +
                             span(groups.closer, 'bracket') +
                             span(groups.postWhitespace, 'wh')}</span>`);
                return element;
            } else if (isMetadataLine(line)) {
                const element = createElement('div', ['line', 'metadata-line', 'highlighted-line']);
                element.innerHTML = replaceAll(line, regexes.metadata, (match, groups) =>
                    `<span>${span(groups.preWhitespace, 'wh') +
                             span(groups.opener, 'brace') +
                             span(groups.content, 'metadata') +
                             span(groups.closer, 'brace') +
                             span(groups.postWhitespace, 'wh')}</span>`);
                return element;
            } else if (isTablatureLine(line)) {
                const element = createElement('div', ['line', 'tablature-line']);
                element.innerHTML = charSpans(line);
                return element;
            } else {
                const element = createElement('div', 'line');
                element.innerHTML = spanifyChords(line, capoAsWritten, transpose, capo, preferredAccidental);
                return element;
            }
        }

        function inferCapoFromText(text) {
            const lines = text.split('\n');

            for (const line of lines) {
                const capoMetadata = matchFirst(line, regexes.capoMetadata);
                if (capoMetadata) {
                    return toFloat(capoMetadata.groups.capo) ?? 0;
                }
            }

            return 0;
        }

        function parseLines(text) {
            const lines = text.split('\n');
            const result = [];

            for (let i = 0; i < lines.length; i++) {
                if (isWhitespace(lines[i])) {
                    // if two empty lines precede header or metadata line, keep only one
                    if (isWhitespace(lines[i + 1]) && isHighlightedLine(lines[i + 2])) {
                        continue;
                    }

                    // remove up to two empty lines after a header or metadata line,
                    // but keep one empty line if it is between two header/metadata lines
                    if (isHighlightedLine(lines[i - 1]) && !isHighlightedLine(lines[i + 1]) ||
                        isWhitespace(lines[i - 1]) && isHighlightedLine(lines[i - 2])) {
                        continue;
                    }
                }

                result.push(lines[i].trimEnd()); // Trim whitespace from the end of each line

                // enforce one empty line before a header or metadata line
                if (!isWhitespace(lines[i]) && isHighlightedLine(lines[i + 1])) {
                    result.push("");
                }
            };

            // Remove empty lines at the end of the text
            while (result.length > 0 && isWhitespace(result[result.length - 1])) {
                result.pop();
            }

            return result;
        }
    </script>

    <script id="domAndDataManipulationFunctions">
        function redrawContent() {
            doc.content.innerHTML = '';
            doc.content.style.fontSize = data.fontSize.get() + 'px';

            doc.contentWrapper.style.padding = `${data.padding.get()}px 0px`;
            doc.contentWrapper.style.margin = `0px ${data.padding.get()}px`;

            applyClass(doc.content, data.colorfulChords.get(), 'colorful-chords');
            applyClass(doc.content, data.colorfulHeaders.get(), 'colorful-headers');

            const availableHeight = elementSize(doc.content, {includePadding: false, includeMargin: false}).height;

            const lines = parseLines(data.text.get());
            const lineElements = lines.map((line, i) => createLineHtmlElement(line,
                                                                              lines[i+1],
                                                                              data.capoAsWritten.get(),
                                                                              data.transpose.get(),
                                                                              data.capo.get(),
                                                                              data.preferredAccidental.get()));

            const columns = [];
            let currentColumn = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const nextLine = lines[i + 1];

                const lineElement = lineElements[i];
                const nextLineElement = lineElements[i + 1];

                let lineFitsCurrentColumn = false;

                if (currentColumn) {
                    currentColumn.div.appendChild(lineElement);
                    let requiredHeight = elementSize(lineElement).height;

                    if (isChordLine(line) && isTextLine(nextLine)) {
                        currentColumn.div.appendChild(nextLineElement);
                        requiredHeight += elementSize(nextLineElement).height;
                        currentColumn.div.removeChild(nextLineElement);
                    }

                    lineFitsCurrentColumn = currentColumn.height + requiredHeight <= availableHeight;

                    if (!lineFitsCurrentColumn) {
                        if (isWhitespace(line)) {
                            lineElement.classList.add('overflow-y-hidden');
                        } else {
                            currentColumn.div.removeChild(lineElement);
                        }
                    } else {
                        currentColumn.width = Math.max(currentColumn.width, elementSize(lineElement).width);
                        currentColumn.height += elementSize(lineElement).height;
                    }
                }

                if (!lineFitsCurrentColumn) {
                    if (isWhitespace(line)) {
                        continue;
                    }

                    const newColumnDiv = createElement('div', 'column', {position: 'absolute', visibility: 'hidden'});
                    doc.content.appendChild(newColumnDiv);
                    newColumnDiv.appendChild(lineElement);

                    currentColumn = {
                        div: newColumnDiv,
                        width: elementSize(lineElement).width,
                        height: elementSize(lineElement).height
                    };

                    columns.push(currentColumn);
                }
            }

            for (const column of columns) {
                column.div.style.width = column.width + 'px';
                column.div.style.position = '';
                column.div.style.visibility = '';
            };

            return elementSize(doc.content).width;
        }

        function redraw(considerRefitting) {
            const minTextLengthForAutoFitting = 100;
            const maxFontSizeForAutoFitting = 20;

            const shouldRefit = considerRefitting &&
                                data.text.get() && data.text.get().length >= minTextLengthForAutoFitting &&
                                !data.fontSize.hasHashParam();

            if (shouldRefit) {
                fullscreen.withTemporaryFullscreen(() => {
                    const defaultFontSize = data.fontSize.get();

                    const availableWidth = elementSize(doc.contentContainer, {includePadding: false, includeMargin: false}).width -
                                           elementSize(doc.leftEdgePixelAnchor).width -
                                           elementSize(doc.rightEdgePixelAnchor).width;

                    const result = findFloorUsingStepBinarySearch(
                        data.fontSize.min,
                        Math.min(data.fontSize.max, maxFontSizeForAutoFitting),
                        data.fontSize.step,
                        data.fontSize.precision,
                        fontSize => {
                            data.fontSize.setElementValueSilently(fontSize);
                            return {fontSize, contentWidth: redrawContent()};
                        },
                        value => compare(value.contentWidth, availableWidth));

                    data.fontSize.setElementValueSilently(result?.fontSize ?? defaultFontSize);
                });
            }

            redrawContent();
        }

        function inferCapo() {
            const inferredCapo = inferCapoFromText(data.text.get());
            if (!data.capoAsWritten.hasHashParam()) {
                data.capoAsWritten.setElementValueSilently(inferredCapo);
                if (!data.capo.hasHashParam()) {
                    data.capo.setElementValueSilently(inferredCapo);
                }
            }
        }

        const fullscreen = {
            isFullScreen: () => document.body.classList.contains('fullscreen'),

            enable: value => {
                applyClass(document.body, value, 'fullscreen');
                redraw(value);
            },

            withTemporaryFullscreen: function(action) {
                const wasFullscreen = this.isFullScreen();
                document.body.classList.add('fullscreen');

                try {
                    action();
                } finally {
                    applyClass(document.body, wasFullscreen, 'fullscreen');
                }
            }
        }
    </script>

    <script id="dataBindings">
        const doc = {};
        document.querySelectorAll('[id]').forEach(element => doc[element.id] = element);

        const data = {
            text: bindData({el: doc.text, hash: true}, (_, previousValue, additionalData) => {
                inferCapo();
                redraw(!previousValue || additionalData?.refit);
            }),
            fontSize: bindData({el: doc.fontSize, hash: true}, () => redraw()),
            transpose: bindData({el: doc.transpose, hash: true}, () => redraw()),
            capo: bindData({el: doc.capo, hash: true}, () => redraw()),
            capoAsWritten: bindData({el: doc.capoAsWritten, hash: true}, () => redraw()),
            preferredAccidental: bindData({el: doc.preferredAccidental, hash: true, cookie: true}, () => redraw()),
            colorfulChords: bindData({el: doc.colorfulChords, hash: true, cookie: true}, () => redraw()),
            colorfulHeaders: bindData({el: doc.colorfulHeaders, hash: true, cookie: true}, () => redraw()),
            padding: bindData({el: doc.padding, hash: true, cookie: true}, () => redraw()),
            title: bindData({hash: 'title'}, value => document.title = value)
        };
    </script>

    <script id="eventListenersSetup">
        window.addEventListener('resize', () => redraw());

        // Add keyboard shortcuts
        document.addEventListener('keydown', e => {
            const anyInputHasFocus = Array.from(document.querySelectorAll('input, textarea'))
                                          .some(item => document.activeElement === item)

            if (anyInputHasFocus) {
                return;
            }

            switch(e.key.toLowerCase()) {
                case 'h': { // Toggle controls visibility with 'h'
                    fullscreen.enable(!fullscreen.isFullScreen());
                    break;
                }

                case 'f': { // Hide controls, if visible, and fit text to screen with 'f'
                    data.fontSize.clearHashParam();
                    fullscreen.enable(true);
                    break;
                }

                case 'n': { // Decrease font size with 'n'
                    data.fontSize.decrease();
                    break;
                }

                case 'm': { // Increase font size with 'm'
                    data.fontSize.increase();
                    break;
                }
            }
        });

        doc.hideButton.addEventListener('click', () => {
            fullscreen.enable(true);
        });

        doc.hideAndFitButton.addEventListener('click', () => {
            data.fontSize.clearHashParam();
            fullscreen.enable(true);
        });

        doc.contentContainer.addEventListener('dblclick', () => {
            if (fullscreen.isFullScreen()) {
                fullscreen.enable(false);
            }
        });

        document.body.addEventListener('paste', e => {
            if (fullscreen.isFullScreen()) {
                const text = (e.clipboardData || window.clipboardData).getData("text");
                if (text && text != data.text.get()) {
                    data.text.set(text, {refit: true});
                    e.preventDefault();
                }
            }
        });

        doc.text.addEventListener('keydown', e => {
            switch(e.key.toLowerCase()) {
                case 'home': {
                    const startOfLine = getStartOfLinePositionForTextAreaCaret(event.target)
                    setTextAreaSelection(event.target, event.shiftKey ? undefined : startOfLine, startOfLine);
                    e.preventDefault();
                    break;
                }

                case 'end': {
                    const endOfLine = getEndOfLinePositionForTextAreaCaret(event.target);
                    setTextAreaSelection(event.target, event.shiftKey ? undefined : endOfLine, endOfLine);
                    e.preventDefault();
                    break;
                }
            }
        });

        if ("IntersectionObserver" in window &&
            "IntersectionObserverEntry" in window &&
            "intersectionRatio" in window.IntersectionObserverEntry.prototype) {

            new IntersectionObserver(entries => applyClass(doc.contentContainer, !entries[0].isIntersecting, 'has-horizontal-overflow-left'))
                .observe(doc.leftEdgePixelAnchor);

            new IntersectionObserver(entries => applyClass(doc.contentContainer, !entries[0].isIntersecting, 'has-horizontal-overflow-right'))
                .observe(doc.rightEdgePixelAnchor);
        }
    </script>

    <script id="main">
        if (data.title.get()) {
            document.title = data.title.get();
        }

        if (data.text.get()) {
            inferCapo();
            fullscreen.enable(true); // this will also redraw
        }
    </script>
</body>
</html>